<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rogue Waves — Single‑File Roguelike</title>
<style>
  :root{
    /* Dark Theme Base */
    --bg-primary: #0a0d14;
    --bg-secondary: #151a26;
    --bg-tertiary: #1e2533;
    --bg-overlay: rgba(10, 13, 20, 0.95);
    
    /* Accent Colors */
    --accent-primary: #00d4ff;
    --accent-secondary: #7c3aed;
    --accent-tertiary: #f59e0b;
    --accent-success: #10b981;
    --accent-danger: #ef4444;
    --accent-warning: #f59e0b;
    
    /* Text Colors */
    --text-primary: #f8fafc;
    --text-secondary: #cbd5e1;
    --text-muted: #94a3b8;
    --text-accent: #00d4ff;
    
    /* UI Elements */
    --border-primary: #334155;
    --border-secondary: #475569;
    --border-accent: #00d4ff;
    
    /* Status Colors */
    --hp-color: #ef4444;
    --armor-color: #06b6d4;
    --stamina-color: #f59e0b;
    --coin-color: #eab308;
    
    /* Gang Colors */
    --gang-uptown: #8b5cf6;
    --gang-compton: #ef4444;
    --gang-downtown: #3b82f6;
    --gang-hollywood: #22c55e;
    
    /* Gradients */
    --gradient-primary: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
    --gradient-accent: linear-gradient(135deg, #00d4ff 0%, #7c3aed 100%);
    --gradient-card: linear-gradient(135deg, #1e2533 0%, #151a26 100%);
  }
  *{box-sizing:border-box}
  html,body{
    height:100%;margin:0;padding:0;
    background:var(--bg-primary);
    color:var(--text-primary);
    font:14px/1.5 'Inter', system-ui, -apple-system, sans-serif;
    overflow:hidden;
  }
  #wrap{
    position:fixed;inset:0;
    display:grid;place-items:center;
    background: radial-gradient(ellipse at center, #1a1f2e 0%, #0a0d14 70%);
  }
  canvas{
    background:var(--bg-primary);
    image-rendering:pixelated;
    border:2px solid var(--border-primary);
    border-radius:8px;
    box-shadow: 
      0 0 0 1px var(--border-secondary),
      0 8px 32px rgba(0, 0, 0, 0.6),
      0 0 0 1px rgba(255, 255, 255, 0.05) inset;
  }
  .hud{
    position:fixed;inset:0;pointer-events:none;
    font-weight:500;font-size:13px;
    z-index:1000;
  }
  
  /* HUD Components */
  .hud-component{
    background:var(--bg-overlay);
    border:1px solid var(--border-primary);
    border-radius:12px;
    backdrop-filter:blur(16px);
    box-shadow: 
      0 4px 24px rgba(0, 0, 0, 0.4),
      0 0 0 1px rgba(255, 255, 255, 0.05) inset;
    transition:all 0.3s ease;
  }
  
  .stat-pill{
    padding:8px 16px;
    background:var(--gradient-card);
    border:1px solid var(--border-secondary);
    border-radius:24px;
    backdrop-filter:blur(12px);
    display:flex;align-items:center;gap:8px;
    font-weight:600;font-size:12px;
    box-shadow: 
      0 2px 12px rgba(0, 0, 0, 0.3),
      0 0 0 1px rgba(255, 255, 255, 0.08) inset;
  }
  
  .stat-bar{
    position:relative;
    height:8px;width:120px;
    background:var(--bg-tertiary);
    border:1px solid var(--border-primary);
    border-radius:6px;
    overflow:hidden;
    box-shadow:inset 0 2px 4px rgba(0,0,0,0.4);
  }
  
  .stat-bar > .fill{
    position:absolute;inset:0;
    transform-origin:left center;
    transition:transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    border-radius:4px;
  }
  
  .hp-fill{
    background:linear-gradient(90deg, var(--hp-color), #dc2626);
    box-shadow:0 0 8px rgba(239, 68, 68, 0.5);
  }
  .armor-fill{
    background:linear-gradient(90deg, var(--armor-color), #0891b2);
    box-shadow:0 0 8px rgba(6, 182, 212, 0.5);
  }
  .stamina-fill{
    background:linear-gradient(90deg, var(--stamina-color), #d97706);
    box-shadow:0 0 8px rgba(245, 158, 11, 0.5);
  }
  /* HUD Layout Zones */
  .hud-top-left{
    position:absolute;top:20px;left:20px;
    display:flex;flex-direction:column;gap:12px;
    max-width:400px;
  }
  
  .hud-top-right{
    position:absolute;top:20px;right:20px;
    display:flex;flex-direction:column;gap:12px;align-items:flex-end;
    max-width:300px;
  }
  
  .hud-bottom-left{
    position:absolute;bottom:20px;left:20px;
    display:flex;gap:16px;align-items:flex-end;
  }
  
  .hud-bottom-right{
    position:absolute;bottom:20px;right:20px;
    display:flex;flex-direction:column;gap:12px;align-items:flex-end;
  }
  
  .hud-center-left{
    position:absolute;left:20px;top:50%;
    transform:translateY(-50%);
    display:flex;flex-direction:column;gap:8px;
  }
  
  /* Status Row */
  .status-row{
    display:flex;gap:16px;align-items:center;
    flex-wrap:wrap;
  }
  
  .info-row{
    display:flex;gap:12px;align-items:center;
    flex-wrap:wrap;
  }
  /* Minimap */
  .minimap{
    width:160px;height:100px;
    border:2px solid var(--border-primary);
    border-radius:8px;
    background:var(--bg-tertiary);
    box-shadow: 
      0 4px 16px rgba(0, 0, 0, 0.4),
      0 0 0 1px rgba(255, 255, 255, 0.05) inset;
  }
  
  /* Weapon Display */
  .weapon-display{
    display:flex;flex-direction:column;gap:6px;
    min-width:200px;
  }
  
  .weapon-slot{
    background:var(--gradient-card);
    border:1px solid var(--border-secondary);
    border-radius:8px;padding:12px;
    display:flex;align-items:center;gap:12px;
    transition:all 0.2s ease;
    cursor:pointer;
    position:relative;
    overflow:hidden;
  }
  
  .weapon-slot::before{
    content:'';position:absolute;inset:0;
    background:var(--gradient-accent);
    opacity:0;transition:opacity 0.2s ease;
    z-index:0;
  }
  
  .weapon-slot.equipped{
    border-color:var(--accent-primary);
    box-shadow:0 0 16px rgba(0, 212, 255, 0.3);
  }
  
  .weapon-slot.equipped::before{opacity:0.1;}
  
  .weapon-slot:hover{
    transform:translateX(4px);
    border-color:var(--border-accent);
  }
  
  .weapon-icon{
    width:40px;height:24px;
    border-radius:4px;
    position:relative;z-index:1;
  }
  
  .weapon-info{
    flex:1;position:relative;z-index:1;
  }
  
  .weapon-name{
    font-weight:600;font-size:13px;
    color:var(--text-primary);
    margin-bottom:2px;
  }
  
  .weapon-stats{
    font-size:11px;
    color:var(--text-muted);
    line-height:1.3;
  }
  
  .weapon-ammo{
    font-size:11px;
    color:var(--accent-primary);
    font-weight:600;
    margin-top:4px;
  }
  /* Panels & Modals */
  .panel{
    position:fixed;inset:0;
    display:none;place-items:center;
    background:var(--bg-overlay);
    backdrop-filter:blur(20px);
    z-index:9999;
    animation:panelFadeIn 0.3s ease;
  }
  
  @keyframes panelFadeIn{
    from{opacity:0;backdrop-filter:blur(0px);}
    to{opacity:1;backdrop-filter:blur(20px);}
  }
  
  .card{
    pointer-events:auto;
    background:var(--gradient-card);
    border:2px solid var(--border-primary);
    border-radius:20px;
    box-shadow: 
      0 20px 60px rgba(0, 0, 0, 0.6),
      0 0 0 1px rgba(255, 255, 255, 0.1) inset;
    padding:32px;
    min-width:min(90vw, 800px);
    max-height:90vh;
    overflow-y:auto;
    animation:cardSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
  }
  
  @keyframes cardSlideIn{
    from{transform:translateY(40px) scale(0.95);opacity:0;}
    to{transform:translateY(0) scale(1);opacity:1;}
  }
  
  /* Typography */
  h1{
    margin:0 0 8px 0;
    font-size:32px;font-weight:700;
    background:var(--gradient-accent);
    -webkit-background-clip:text;
    background-clip:text;
    -webkit-text-fill-color:transparent;
    letter-spacing:-0.02em;
  }
  
  h2{
    margin:0 0 24px 0;
    font-size:18px;font-weight:400;
    color:var(--text-secondary);
  }
  
  /* Layout Grids */
  .grid{display:grid;gap:16px;}
  .g2{grid-template-columns:repeat(2,minmax(0,1fr));}
  .g3{grid-template-columns:repeat(3,minmax(0,1fr));}
  
  /* Buttons */
  .btn{
    cursor:pointer;
    border:1px solid var(--border-secondary);
    background:var(--gradient-card);
    color:var(--text-primary);
    padding:12px 24px;
    border-radius:12px;
    font-weight:600;font-size:14px;
    text-align:center;
    transition:all 0.2s ease;
    position:relative;
    overflow:hidden;
  }
  
  .btn::before{
    content:'';position:absolute;inset:0;
    background:var(--gradient-accent);
    opacity:0;transition:opacity 0.2s ease;
  }
  
  .btn:hover{
    transform:translateY(-2px);
    border-color:var(--border-accent);
    box-shadow:0 8px 24px rgba(0, 0, 0, 0.3);
  }
  
  .btn:hover::before{opacity:0.1;}
  
  .btn.primary{
    background:var(--gradient-accent);
    border-color:var(--accent-primary);
    color:var(--text-primary);
    box-shadow:0 4px 16px rgba(0, 212, 255, 0.3);
  }
  
  .btn.primary:hover{
    box-shadow:0 8px 32px rgba(0, 212, 255, 0.4);
  }
  
  .btn.warn{
    background:linear-gradient(135deg, var(--accent-danger), #dc2626);
    border-color:var(--accent-danger);
    color:var(--text-primary);
  }
  
  .btn-row{
    display:flex;gap:12px;
    justify-content:flex-end;
    margin-top:24px;
  }
  
  /* Tags & Pills */
  .tag{
    display:inline-flex;gap:6px;align-items:center;
    background:var(--bg-tertiary);
    border:1px solid var(--border-primary);
    padding:6px 12px;
    border-radius:20px;
    font-size:12px;font-weight:500;
    color:var(--text-secondary);
  }
  
  .tag-list{
    display:flex;flex-wrap:wrap;gap:8px;
  }
  
  /* Content Cards */
  .content-card{
    background:var(--bg-secondary);
    border:1px solid var(--border-primary);
    border-radius:12px;
    padding:16px;
    transition:all 0.2s ease;
  }
  
  .content-card:hover{
    border-color:var(--border-secondary);
    transform:translateY(-1px);
  }
  
  .content-card h3{
    margin:0 0 8px 0;
    font-size:16px;font-weight:600;
    color:var(--text-primary);
  }
  
  .price{
    color:var(--coin-color);
    font-weight:700;
    font-size:16px;
  }
  
  .muted{color:var(--text-muted);}
  .small{font-size:12px;}
  
  .credit{
    opacity:0.6;
    font-size:12px;
    margin-top:16px;
    text-align:center;
    color:var(--text-muted);
  }
</style>
</head>
<body>
<div id="wrap"><canvas id="game" width="1600" height="900"></canvas></div>
<img id="bgImg" src="sprites/backgrounds/bg.png" style="display:none" alt="bg"/>
<img id="bgUptown" src="sprites/backgrounds/zone_uptown.png" style="display:none" alt="uptown"/>
<img id="bgCompton" src="sprites/backgrounds/zone_compton.png" style="display:none" alt="compton"/>
<img id="bgDowntown" src="sprites/backgrounds/zone_downtown.png" style="display:none" alt="downtown"/>
<img id="bgHollywood" src="sprites/backgrounds/zone_hollywood.png" style="display:none" alt="hollywood"/>
<img id="pIdle" src="sprites/characters/player_idle.png" style="display:none" alt="idle"/>
<img id="pLeft" src="sprites/characters/player_L.png" style="display:none" alt="left"/>
<img id="pRight" src="sprites/characters/player_R.png" style="display:none" alt="right"/>
<img id="gIdle" src="sprites/enemies/grunt_idle.png" style="display:none" alt="g_idle"/>
<img id="gLeft" src="sprites/enemies/grunt_L.png" style="display:none" alt="g_left"/>
<img id="gRight" src="sprites/enemies/grunt_R.png" style="display:none" alt="g_right"/>
<img id="sIdle" src="sprites/enemies/swarmer_idle.png" style="display:none" alt="s_idle"/>
<img id="sLeft" src="sprites/enemies/swarmer_L.png" style="display:none" alt="s_left"/>
<img id="sRight" src="sprites/enemies/swarmer_R.png" style="display:none" alt="s_right"/>
<img id="sUp" src="sprites/enemies/swarmer_U.png" style="display:none" alt="s_up"/>
<img id="sDown" src="sprites/enemies/swarmer_D.png" style="display:none" alt="s_down"/>
<img id="tIdle" src="sprites/enemies/tank_idle.png" style="display:none" alt="t_idle"/>
<img id="tLeft" src="sprites/enemies/tank_L.png" style="display:none" alt="t_left"/>
<img id="tRight" src="sprites/enemies/tank_R.png" style="display:none" alt="t_right"/>
<img id="tUp" src="sprites/enemies/tank_U.png" style="display:none" alt="t_up"/>
<img id="tDown" src="sprites/enemies/tank_D.png" style="display:none" alt="t_down"/>
<img id="bagImg" src="sprites/items/money_bag.png" style="display:none" alt="bag"/>
<img id="vSprite" src="sprites/vehicles/copcar_player.png" style="display:none" alt="vehicle"/>
<img id="vWreck" src="sprites/vehicles/copcar_wreck.png" style="display:none" alt="vehicle_wreck"/>
<img id="bFranklin" src="sprites/bosses/boss_franklin.png" style="display:none" alt="boss_franklin"/>
<img id="bTrevor" src="sprites/bosses/boss_trevor.png" style="display:none" alt="boss_trevor"/>
<img id="npcSlickback" src="sprites/npcs/npc_slickback.png" style="display:none" alt="slickback"/>
<img id="npcDeebo" src="sprites/npcs/npc_deebo.png" style="display:none" alt="deebo"/>
<img id="npcSmokey" src="sprites/npcs/npc_smokey.png" style="display:none" alt="smokey"/>
<img id="npcCraig" src="sprites/npcs/npc_craig.png" style="display:none" alt="craig"/>
<img id="npcShopkeeper" src="sprites/npcs/npc_shopkeeper.png" style="display:none" alt="shopkeeper"/>

<!-- Quest Boss Sprites - 5 sprites each (idle, L1, L2, R1, R2) -->
<!-- Sex Trafficker (Hollywood) -->
<img id="bossTraffickerIdle" src="sprites/bosses/boss_trafficker_idle.png" style="display:none" alt="trafficker_idle"/>
<img id="bossTraffickerL1" src="sprites/bosses/boss_trafficker_L1.png" style="display:none" alt="trafficker_L1"/>
<img id="bossTraffickerL2" src="sprites/bosses/boss_trafficker_L2.png" style="display:none" alt="trafficker_L2"/>
<img id="bossTraffickerR1" src="sprites/bosses/boss_trafficker_R1.png" style="display:none" alt="trafficker_R1"/>
<img id="bossTraffickerR2" src="sprites/bosses/boss_trafficker_R2.png" style="display:none" alt="trafficker_R2"/>

<!-- Chain Snatcher (Compton) -->
<img id="bossSnatcherIdle" src="sprites/bosses/boss_snatcher_idle.png" style="display:none" alt="snatcher_idle"/>
<img id="bossSnatcherL1" src="sprites/bosses/boss_snatcher_L1.png" style="display:none" alt="snatcher_L1"/>
<img id="bossSnatcherL2" src="sprites/bosses/boss_snatcher_L2.png" style="display:none" alt="snatcher_L2"/>
<img id="bossSnatcherR1" src="sprites/bosses/boss_snatcher_R1.png" style="display:none" alt="snatcher_R1"/>
<img id="bossSnatcherR2" src="sprites/bosses/boss_snatcher_R2.png" style="display:none" alt="snatcher_R2"/>

<!-- Rainbow Hippie (Uptown) -->
<img id="bossHippieIdle" src="sprites/bosses/boss_hippie_idle.png" style="display:none" alt="hippie_idle"/>
<img id="bossHippieL1" src="sprites/bosses/boss_hippie_L1.png" style="display:none" alt="hippie_L1"/>
<img id="bossHippieL2" src="sprites/bosses/boss_hippie_L2.png" style="display:none" alt="hippie_L2"/>
<img id="bossHippieR1" src="sprites/bosses/boss_hippie_R1.png" style="display:none" alt="hippie_R1"/>
<img id="bossHippieR2" src="sprites/bosses/boss_hippie_R2.png" style="display:none" alt="hippie_R2"/>

<!-- Fake King (Downtown) -->
<img id="bossKingIdle" src="sprites/bosses/boss_king_idle.png" style="display:none" alt="king_idle"/>
<img id="bossKingL1" src="sprites/bosses/boss_king_L1.png" style="display:none" alt="king_L1"/>
<img id="bossKingL2" src="sprites/bosses/boss_king_L2.png" style="display:none" alt="king_L2"/>
<img id="bossKingR1" src="sprites/bosses/boss_king_R1.png" style="display:none" alt="king_R1"/>
<img id="bossKingR2" src="sprites/bosses/boss_king_R2.png" style="display:none" alt="king_R2"/>
<img id="bridgeHorizontal" src="sprites/bridges/bridge_horizontal.png" style="display:none" alt="horizontal_bridge"/>
<img id="bridgeVertical" src="sprites/bridges/bridge_vertical.png" style="display:none" alt="vertical_bridge"/>
<img id="interiorHollywoodHQ" src="sprites/backgrounds/interior_hollywood_hq.png" style="display:none" alt="hollywood_hq_interior"/>
<img id="interiorUptownHQ" src="sprites/backgrounds/interior_uptown_hq.png" style="display:none" alt="uptown_hq_interior"/>
<img id="interiorComptonHQ" src="sprites/backgrounds/interior_compton_hq.png" style="display:none" alt="compton_hq_interior"/>
<img id="interiorDowntownHQ" src="sprites/backgrounds/interior_downtown_hq.png" style="display:none" alt="downtown_hq_interior"/>
<img id="interiorShop" src="sprites/backgrounds/interior_shop.png" style="display:none" alt="shop_interior"/>
<!-- Vehicle Sprites with Directional Movement -->
<!-- Police Car (Stage 1) -->
<img id="copCarIdle" src="sprites/vehicles/copcar_player.png" style="display:none" alt="cop_car"/>
<img id="copCarLeft" src="sprites/vehicles/copcar_L.png" style="display:none" alt="cop_car_left"/>
<img id="copCarRight" src="sprites/vehicles/copcar_R.png" style="display:none" alt="cop_car_right"/>
<img id="copCarUp" src="sprites/vehicles/copcar_U.png" style="display:none" alt="cop_car_up"/>
<img id="copCarDown" src="sprites/vehicles/copcar_D.png" style="display:none" alt="cop_car_down"/>
<!-- Super Car (Stage 2) -->
<img id="superCarIdle" src="sprites/vehicles/super_car_idle.png" style="display:none" alt="super_car"/>
<img id="superCarLeft" src="sprites/vehicles/super_car_L.png" style="display:none" alt="super_car_left"/>
<img id="superCarRight" src="sprites/vehicles/super_car_R.png" style="display:none" alt="super_car_right"/>
<img id="superCarUp" src="sprites/vehicles/super_car_U.png" style="display:none" alt="super_car_up"/>
<img id="superCarDown" src="sprites/vehicles/super_car_D.png" style="display:none" alt="super_car_down"/>
<!-- Ferrari -->
<img id="ferrariIdle" src="sprites/vehicles/ferrari_idle.png" style="display:none" alt="ferrari"/>
<img id="ferrariLeft" src="sprites/vehicles/ferrari_L.png" style="display:none" alt="ferrari_left"/>
<img id="ferrariRight" src="sprites/vehicles/ferrari_R.png" style="display:none" alt="ferrari_right"/>
<img id="ferrariUp" src="sprites/vehicles/ferrari_U.png" style="display:none" alt="ferrari_up"/>
<img id="ferrariDown" src="sprites/vehicles/ferrari_D.png" style="display:none" alt="ferrari_down"/>
<!-- Armored Van -->
<img id="armoredVanIdle" src="sprites/vehicles/armored_van_idle.png" style="display:none" alt="armored_van"/>
<img id="armoredVanLeft" src="sprites/vehicles/armored_van_L.png" style="display:none" alt="armored_van_left"/>
<img id="armoredVanRight" src="sprites/vehicles/armored_van_R.png" style="display:none" alt="armored_van_right"/>
<img id="armoredVanUp" src="sprites/vehicles/armored_van_U.png" style="display:none" alt="armored_van_up"/>
<img id="armoredVanDown" src="sprites/vehicles/armored_van_D.png" style="display:none" alt="armored_van_down"/>
<!-- SFX audio tags -->
<audio id="sfx_pistol" src="pistol.mp3" preload="auto"></audio>
<audio id="sfx_rifle" src="rifle.mp3" preload="auto"></audio>
<audio id="sfx_smg" src="smg.mp3" preload="auto"></audio>
<audio id="sfx_shotgun" src="shotgun.mp3" preload="auto"></audio>
<audio id="sfx_rpg_fire" src="rpg_fire.mp3" preload="auto"></audio>
<audio id="sfx_rpg_explosion" src="rpg_explosion.mp3" preload="auto"></audio>
<audio id="bgm" src="bgm.mp3" preload="auto" loop></audio>
<audio id="bgm_franklin" src="franklin.mp3" preload="auto" loop></audio>
<audio id="bgm_trevor" src="trevor.mp3" preload="auto" loop></audio>
<audio id="bgm_menu" src="menu.mp3" preload="auto" loop></audio>
<div class="hud" id="hud">
  <!-- Top Left: Player Status -->
  <div class="hud-top-left">
    <div class="status-row">
      <!-- Health -->
      <div class="stat-pill">
        <div style="display:flex;align-items:center;gap:8px;">
          <div style="color:var(--hp-color);font-weight:700;">❤</div>
          <span id="hpText">100</span>/<span id="hpMaxText">100</span>
        </div>
        <div class="stat-bar">
          <div class="fill hp-fill" id="hpBar" style="transform:scaleX(1)"></div>
        </div>
      </div>
      
      <!-- Armor -->
      <div class="stat-pill">
        <div style="display:flex;align-items:center;gap:8px;">
          <div style="color:var(--armor-color);font-weight:700;">🛡</div>
          <span id="armText">0</span>
        </div>
        <div class="stat-bar">
          <div class="fill armor-fill" id="armBar" style="transform:scaleX(0)"></div>
        </div>
      </div>
      
      <!-- Stamina -->
      <div class="stat-pill">
        <div style="display:flex;align-items:center;gap:8px;">
          <div style="color:var(--stamina-color);font-weight:700;">⚡</div>
          <span>STAMINA</span>
        </div>
        <div class="stat-bar">
          <div class="fill stamina-fill" id="stBar" style="transform:scaleX(1)"></div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Top Right: Game Info & Objectives -->
  <div class="hud-top-right">
    <div class="info-row">
      <div class="stat-pill">
        <span style="color:var(--text-accent);font-weight:700;">WAVE</span>
        <span id="waveText">1</span>
      </div>
      <div class="stat-pill">
        <span style="color:var(--coin-color);font-weight:700;">💰</span>
        <span id="coinsText">0</span>
      </div>
      <div class="stat-pill">
        <span style="color:var(--text-muted);">SCORE</span>
        <span id="scoreText">0</span>
      </div>
    </div>
    
    <!-- Wanted Level -->
    <div class="stat-pill" id="starsPill" title="Wanted Level">
      <span style="color:var(--accent-danger);font-weight:700;">WANTED</span>
      <div id="starsContainer"></div>
    </div>
    
    <!-- Objectives -->
    <div class="hud-component" id="objectivesHUD" style="display:none;padding:16px;min-width:280px;">
      <div style="color:var(--text-accent);font-weight:700;margin-bottom:12px;font-size:14px;">
        📋 OBJECTIVES
      </div>
      <ul id="objectivesList" style="margin:0;padding:0;list-style:none;"></ul>
    </div>
  </div>
  
  <!-- Center Left: Weapons -->
  <div class="hud-center-left">
    <div class="weapon-display" id="weaponDisplay">
      <!-- Weapon slots populated by JavaScript -->
    </div>
  </div>
  
  <!-- Bottom Left: Minimap -->
  <div class="hud-bottom-left">
    <div class="hud-component" style="padding:12px;">
      <div style="color:var(--text-secondary);font-size:11px;margin-bottom:8px;font-weight:600;">
        🗺 MINIMAP
      </div>
      <canvas class="minimap" id="miniMapCanvas" width="160" height="100"></canvas>
    </div>
  </div>
  
  <!-- Bottom Right: Legacy & Seed -->
  <div class="hud-bottom-right">
    <div class="stat-pill" id="legacyPill" title="Legacy Buffs">
      <span style="color:var(--accent-secondary);font-weight:700;">⭐</span>
      <span id="legacyText" style="font-size:11px;">+0% move, +0% dmg, +0 ARM, +0% luck</span>
    </div>
    <div class="stat-pill">
      <span style="color:var(--text-muted);">SEED</span>
      <span id="seedText" style="font-size:11px;">0</span>
    </div>
  </div>
</div>

<!-- Main Menu -->
<div class="panel" id="menu">
  <div class="card" style="max-width:1000px;padding:40px;">
    <!-- Header Section -->
    <div style="text-align:center;margin-bottom:40px;">
      <!-- Game Logo Placeholder -->
      <div style="width:400px;height:120px;margin:0 auto 20px;background:var(--gradient-accent);border-radius:16px;display:flex;align-items:center;justify-content:center;border:2px solid var(--border-accent);box-shadow:0 8px 32px rgba(0,212,255,0.3);">
        <div style="color:var(--text-primary);font-size:32px;font-weight:700;text-shadow:2px 2px 4px rgba(0,0,0,0.5);">
          ROGUE WAVES
        </div>
      </div>
      <h2 style="max-width:600px;margin:0 auto;">Top‑down roguelike arena. Survive, shop, die, grow stronger.</h2>
    </div>
    
    <div class="grid g2" style="gap:40px;">
      <!-- Left Side: Game Info & Stats -->
      <div>
        <!-- Character Preview Placeholder -->
        <div class="content-card" style="margin-bottom:24px;">
          <h3>Character Preview</h3>
          <div style="width:100%;height:200px;background:var(--bg-tertiary);border-radius:12px;display:flex;align-items:center;justify-content:center;border:2px dashed var(--border-secondary);">
            <div style="text-align:center;color:var(--text-muted);">
              <div style="font-size:24px;margin-bottom:8px;">🎮</div>
              <div>Character Sprite Placeholder</div>
            </div>
          </div>
        </div>
        
        <!-- Controls -->
        <div class="content-card">
          <h3>Controls</h3>
          <div class="tag-list">
            <span class="tag">WASD: Move</span>
            <span class="tag">Mouse: Aim</span>
            <span class="tag">LMB/Space: Fire</span>
            <span class="tag">R: Reload</span>
            <span class="tag">Q/Wheel: Switch</span>
            <span class="tag">Shift: Dash</span>
            <span class="tag">F: Interact</span>
            <span class="tag">T: Talk</span>
            <span class="tag">Esc: Pause</span>
          </div>
          <div class="muted small" style="margin-top:12px;">
            All guns use projectiles except <strong>player</strong> snipers (hitscan).
          </div>
        </div>
        
        <!-- Best Score -->
        <div class="content-card" style="margin-top:16px;">
          <div style="display:flex;align-items:center;justify-content:space-between;">
            <span style="color:var(--text-secondary);">Best Score</span>
            <span style="color:var(--accent-primary);font-weight:700;font-size:18px;" id="bestText">0</span>
          </div>
        </div>
      </div>
      
      <!-- Right Side: Actions & Menu -->
      <div>
        <!-- Featured Image Placeholder -->
        <div style="width:100%;height:200px;background:var(--bg-tertiary);border-radius:16px;margin-bottom:32px;display:flex;align-items:center;justify-content:center;border:2px dashed var(--border-secondary);background-image:linear-gradient(45deg, var(--bg-tertiary) 25%, transparent 25%), linear-gradient(-45deg, var(--bg-tertiary) 25%, transparent 25%), linear-gradient(45deg, transparent 75%, var(--bg-tertiary) 75%), linear-gradient(-45deg, transparent 75%, var(--bg-tertiary) 75%);background-size:20px 20px;background-position:0 0, 0 10px, 10px -10px, -10px 0px;">
          <div style="text-align:center;color:var(--text-muted);background:var(--bg-primary);padding:20px;border-radius:12px;">
            <div style="font-size:32px;margin-bottom:8px;">🖼️</div>
            <div>Featured Artwork Placeholder</div>
            <div style="font-size:12px;margin-top:4px;">Add your game screenshot here</div>
          </div>
        </div>
        
        <!-- Main Actions -->
        <div class="grid g2" style="gap:16px;margin-bottom:24px;">
          <button class="btn primary" id="startBtn" style="font-size:16px;padding:16px;">
            ▶ Start Game
          </button>
          <button class="btn" id="hardBtn" style="font-size:16px;padding:16px;">
            🔥 Hard Mode
          </button>
        </div>
        
        <!-- Secondary Actions -->
        <div class="grid g2" style="gap:12px;">
          <button class="btn" id="howBtn">📖 How to Play</button>
          <button class="btn" id="settingsBtn">⚙️ Settings</button>
          <button class="btn" id="resetLegacyBtn">🔄 Reset Legacy</button>
          <button class="btn" id="reseedBtn">🎲 Re‑Seed</button>
        </div>
      </div>
    </div>
    
    <div class="credit">
      Roguelike Arena Game • Built with HTML5 Canvas
    </div>
  </div>
</div>

<!-- Pause Panel -->
<div class="panel" id="pause">
  <div class="card">
    <h1>Paused</h1>
    <div class="grid g2">
      <div>
        <div class="list">
          <span class="tag">Wave: <span id="pWave">1</span></span>
          <span class="tag">Score: <span id="pScore">0</span></span>
          <span class="tag">Seed: <span id="pSeed">0</span></span>
        </div>
        <div style="margin-top:8px" class="muted">Legacy: <span id="pLegacy">–</span></div>
      </div>
      <div class="grid g2">
        <button class="btn" id="resumeBtn">Resume</button>
        <button class="btn" id="pauseSettingsBtn">Settings</button>
        <button class="btn" id="pauseObjectivesBtn">Objectives</button>
        <button class="btn warn" id="quitBtn">Quit to Menu</button>
      </div>
    </div>
  </div>
</div>

<!-- Settings Panel -->
<div class="panel" id="settings">
  <div class="card">
    <h1>Settings</h1>
    <div class="grid g3">
      <div>
        <label>Music Volume <input type="range" min="0" max="1" step="0.01" id="musicVol"></label>
      </div>
      <div>
        <label>SFX Volume <input type="range" min="0" max="1" step="0.01" id="sfxVol"></label>
      </div>
      <div>
        <label><input type="checkbox" id="shakeToggle"> Screen Shake</label>
      </div>
      <div>
        <label><input type="checkbox" id="dmgNumToggle"> Damage Numbers</label>
      </div>
      <div>
        <label><input type="checkbox" id="reduceMotion"> Reduced Motion</label>
      </div>
      <div>
        <label><input type="checkbox" id="highContrast"> High Contrast Palette</label>
      </div>
    </div>
    <div class="btnRow"><button class="btn" id="closeSettings">Close</button></div>
  </div>
</div>

<!-- Shop Panel -->
<div class="panel" id="shop">
  <div class="card">
    <h1>Intermission Shop</h1>
    <div class="muted small">Spend coins, then Continue. Inventory is small; new weapons replace current unless you have a free slot.</div>
    <div id="shopGrid" class="grid g3" style="margin-top:10px"></div>
    <div class="btnRow">
      <div class="muted">Coins: <span id="shopCoins">0</span></div>
      <button class="btn primary" id="continueBtn">Continue</button>
    </div>
  </div>
</div>

<!-- Game Over / Legacy Choice -->
<div class="panel" id="gameover">
  <div class="card">
    <h1>Game Over</h1>
    <div class="muted">Score: <span id="goScore">0</span> • Wave: <span id="goWave">1</span></div>
    <h2>Choose a Legacy Buff (pick 1)</h2>
    <div id="legacyChoices" class="grid g3"></div>
    <div class="btnRow">
      <button class="btn" id="rerollLegacy">Reroll (1x)</button>
      <button class="btn primary" id="takeLegacy" disabled>Take Selection & Restart</button>
    </div>
  </div>
</div>

<!-- How-to panel -->
<div class="panel" id="how">
  <div class="card">
    <h1>How to Play</h1>
    <p>Survive waves. Early waves are melee only; later waves add ranged foes with projectiles. Between waves, a short shop phase lets you buy upgrades. When you die, choose a small permanent Legacy buff that stacks across runs.</p>
    <ul>
      <li>All firearms use <b>projectiles</b> except the <b>player sniper</b> (hitscan).</li>
      <li>Dash to evade, reload wisely, and use cover. Enemies kite, strafe, and synchronize volleys.</li>
      <li>Legacy buffs: Move +2%, Damage +2%, Armor +1 (or +2% DR), Luck +2%, Reload +3%, Lifesteal +0.5%, Max HP +5 (each with sensible caps).</li>
    </ul>
    <div class="btnRow"><button class="btn" id="howClose">Close</button></div>
  </div>
</div>

<!-- Stage 2 Transition Panel -->
<div class="panel" id="stage2Panel">
  <div class="card">
    <h1>Entering Stage Two</h1>
    <h2>The city expands. New zones, new challenges.</h2>
    <div class="muted">Get ready... the camera will zoom out to reveal the expanded map.</div>
    <div class="btnRow"><button class="btn primary" id="stage2StartBtn">Continue</button></div>
  </div>
</div>

<!-- Objectives Detail Panel -->
<div class="panel" id="objectivesPanel">
  <div class="card">
    <h1>Objectives</h1>
    <div id="objectivesDetail" class="grid"></div>
    <div class="btnRow"><button class="btn" id="closeObjectives">Close</button></div>
  </div>
</div>

<!-- Gang Dialogue Panel -->
<div class="panel" id="gangDialoguePanel">
  <div class="card" style="max-width:800px;">
    <div style="display:flex;gap:20px;align-items:center;">
      <div id="gangLeaderSprite" style="width:120px;height:120px;background:#223045;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:14px;color:#8aa1b5;">
        [NPC Sprite]
      </div>
      <div style="flex:1;">
        <h2 id="gangLeaderName" style="margin:0;font-size:24px;"></h2>
        <div id="gangDialogue" style="margin-top:10px;line-height:1.6;"></div>
      </div>
    </div>
    <div class="btn-row">
      <button class="btn" id="declineGangBtn">Leave</button>
      <button class="btn primary" id="joinGangBtn">Join Gang</button>
    </div>
  </div>
</div>

<!-- Shop Panel -->
<div class="panel" id="shopPanel">
  <div class="card" style="max-width:900px;">
    <div style="display:flex;gap:20px;align-items:center;margin-bottom:24px;">
      <div id="shopkeeperSprite" style="width:100px;height:100px;background:var(--bg-tertiary);border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:14px;color:var(--text-muted);border:2px dashed var(--border-primary);">
        🛒 Shopkeeper
      </div>
      <div style="flex:1;">
        <h1 id="shopTitle">Gang Supply Store</h1>
        <h2 id="shopSubtitle">Exclusive items for gang members</h2>
        <div style="display:flex;gap:16px;align-items:center;">
          <span style="color:var(--coin-color);font-weight:700;">💰</span>
          <span id="shopCoinsDisplay">0</span> coins
        </div>
      </div>
    </div>
    
    <div id="shopItemsGrid" class="grid g3" style="margin-bottom:24px;">
      <!-- Shop items populated by JavaScript -->
    </div>
    
    <div class="btn-row">
      <button class="btn" id="closeShopBtn">Leave Store</button>
    </div>
  </div>
</div>

<script>
(() => {
'use strict';
// ========================================
// GAME BALANCE & TUNING SECTION
// ========================================
// This section contains ALL the values you can modify to tune the game balance
// Look for "TUNE:" comments to find specific values you can adjust

// -----------------------------
// Utilities & RNG (Mulberry32)
// -----------------------------
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const TAU=Math.PI*2;
function mulberry32(seed){let t=seed>>>0;return function(){t+=0x6D2B79F5;let r=Math.imul(t^(t>>>15),1|t);r^=r+Math.imul(r^(r>>>7),61|r);return ((r^(r>>>14))>>>0)/4294967296;}}
function hashStr(s){let h=1779033703^s.length;for(let i=0;i<s.length;i++){h=Math.imul(h^s.charCodeAt(i),3432918353);h=h<<13|h>>>19;}return (h>>>0);}
const R = { rng: mulberry32(1), seed:1, reseed(v){R.seed=v>>>0; R.rng=mulberry32(R.seed); setTxt('seedText', R.seed); setTxt('pSeed', R.seed);} , rand(){return R.rng();}, rint(a,b){return Math.floor(lerp(a,b+1,R.rand()));}, pick(arr){return arr[Math.floor(R.rand()*arr.length)]}, chance(p){return R.rand()<p} };

// -----------------------------
// DOM helpers
// -----------------------------
const $ = sel=>document.querySelector(sel);
const setTxt=(id, v)=>{const el=(typeof id==='string')?document.getElementById(id):id; if(el) el.textContent=v;};
const show = (id, on=true)=>{(typeof id==='string'?document.getElementById(id):id).style.display=on?'grid':'none';};

// Safe image checking helper
function isImageReady(img) {
  return img && img.complete && img.naturalWidth > 0 && img.naturalHeight > 0 && !img.src.endsWith('undefined');
}

// ========================================
// BIOME SYSTEM HELPERS
// ========================================
function getBiomesByType(type) {
  return TUNE.biomes.instances.filter(b => b.type === type);
}

function getBiomeById(id) {
  return TUNE.biomes.instances.find(b => b.id === id);
}

function getBiomeAt(x, y) {
  for(const biome of TUNE.biomes.instances) {
    if(x >= biome.x && x <= biome.x + biome.w && 
       y >= biome.y && y <= biome.y + biome.h) {
      return biome;
    }
  }
  return null;
}

function isInBiome(x, y, biomeType) {
  const biome = getBiomeAt(x, y);
  return biome && biome.type === biomeType;
}

// Check if entity can pass through a position (rivers block, bridges allow)
function canPassThrough(x, y, entityRadius = 0) {
  for(const biome of TUNE.biomes.instances) {
    const r = entityRadius || 0;
    if(x + r > biome.x && x - r < biome.x + biome.w && 
       y + r > biome.y && y - r < biome.y + biome.h) {
      if(biome.type === 'river') {
        // Check if there's a bridge at this location
        const bridges = getBiomesByType('bridge');
        for(const bridge of bridges) {
          if(x + r > bridge.x && x - r < bridge.x + bridge.w && 
             y + r > bridge.y && y - r < bridge.y + bridge.h) {
            return true; // On bridge, can pass
          }
        }
        return false; // In river without bridge, blocked
      }
    }
  }
  return true; // Not in any blocking biome
}

// ========================================
// OBSTACLE & BUILDING HELPERS
// ========================================
function getObstacleById(id) {
  return obstacles.find(o => o.id === id);
}

function getBuildingById(id) {
  return buildings.find(b => b.id === id);
}

function getObstaclesByBiome(biomeId) {
  return obstacles.filter(o => o.biome === biomeId);
}

function getBuildingsByBiome(biomeId) {
  return buildings.filter(b => b.biome === biomeId);
}

// Update obstacle in TUNE configuration and rebuild
function updateObstacle(id, newProperties) {
  const obstacleConfig = TUNE.obstacles.instances.find(o => o.id === id);
  if(obstacleConfig) {
    Object.assign(obstacleConfig, newProperties);
    // Rebuild obstacles to reflect changes
    if(game.stage === 2) {
      buildBiomeObstacles();
    }
  }
}

// Update building in TUNE configuration and rebuild
function updateBuilding(id, newProperties) {
  const buildingConfig = TUNE.buildings.instances.find(b => b.id === id);
  if(buildingConfig) {
    Object.assign(buildingConfig, newProperties);
    // Rebuild buildings to reflect changes
    if(game.stage === 2) {
      buildBiomeBuildings();
    }
  }
}

// Render all biomes in order
function renderBiomes() {
  // First pass: rivers (background layer)
  const rivers = getBiomesByType('river');
  for(const river of rivers) {
    renderRiverBiome(river);
  }
  
  // Second pass: zones and borough (main content)
  const zones = getBiomesByType('zone');
  const boroughs = getBiomesByType('borough');
  
  for(const zone of zones) {
    renderZoneBiome(zone);
  }
  
  for(const borough of boroughs) {
    renderBoroughBiome(borough);
  }
  
  // Third pass: bridges (overlay)
  const bridges = getBiomesByType('bridge');
  for(const bridge of bridges) {
    renderBridgeBiome(bridge);
  }
}

// Render a river biome
function renderRiverBiome(biome) {
  const config = {...TUNE.biomes.types.river.defaultConfig, ...biome.config};
  
  ctx.save();
  ctx.globalAlpha = 1.0;
  
  // Main water color
  ctx.fillStyle = config.waterColor;
  ctx.fillRect(biome.x, biome.y, biome.w, biome.h);
  
  // Water texture pattern
  ctx.fillStyle = config.textureColor;
  const textureSize = config.textureSize || 8;
  
  for(let y = biome.y; y < biome.y + biome.h; y += textureSize) {
    for(let x = biome.x; x < biome.x + biome.w; x += textureSize * 2) {
      if((Math.floor((x - biome.x) / (textureSize * 2)) + Math.floor((y - biome.y) / textureSize)) % 2) {
        ctx.fillRect(x, y, textureSize, textureSize / 2);
      }
    }
  }
  
  ctx.restore();
}

// Render a zone biome
function renderZoneBiome(biome) {
  const config = {...TUNE.biomes.types.zone.defaultConfig, ...biome.config};
  
  ctx.save();
  ctx.globalAlpha = config.alpha || 0.8;
  
  if(config.backgroundSrc) {
    const bgImg = document.getElementById(getImageIdFromSrc(config.backgroundSrc));
    if(isImageReady(bgImg)) {
      const density = config.tileDensity || 1.0;
      
      if(density === 1.0) {
        // Simple scaling - fill the entire zone (default behavior)
        ctx.drawImage(bgImg, 0, 0, bgImg.naturalWidth, bgImg.naturalHeight, 
                      biome.x, biome.y, biome.w, biome.h);
      } else {
        // Tiled rendering with density control
        const tw = Math.max(8, Math.floor(bgImg.naturalWidth / density));
        const th = Math.max(8, Math.floor(bgImg.naturalHeight / density));
        
        for(let y = biome.y; y < biome.y + biome.h; y += th) {
          for(let x = biome.x; x < biome.x + biome.w; x += tw) {
            ctx.drawImage(bgImg, 0, 0, bgImg.naturalWidth, bgImg.naturalHeight, x, y, tw, th);
          }
        }
      }
    } else {
      // Fallback color based on zone
      const fallbackColors = {
        hollywood: '#1a3a2a',
        uptown: '#2a1a3a', 
        compton: '#3a1a1a',
        downtown: '#1a2a3a'
      };
      ctx.fillStyle = fallbackColors[config.gangData] || '#2a2a2a';
      ctx.fillRect(biome.x, biome.y, biome.w, biome.h);
    }
  }
  
  ctx.restore();
}

// Render a borough biome
function renderBoroughBiome(biome) {
  const config = {...TUNE.biomes.types.borough.defaultConfig, ...biome.config};
  
  const bg = document.getElementById('bgImg');
  if(!isImageReady(bg)) return;
  
  ctx.save();
  ctx.globalAlpha = config.alpha || 0.7;
  
  const scale = config.tileScale || 1;
  const density = config.tileDensity || 1.0;
  
  // Apply tile density - higher density = smaller tiles = more tiles
  const tw = Math.max(8, Math.floor(bg.naturalWidth * scale / density));
  const th = Math.max(8, Math.floor(bg.naturalHeight * scale / density));
  
  for(let y = biome.y; y < biome.y + biome.h; y += th) {
    for(let x = biome.x; x < biome.x + biome.w; x += tw) {
      ctx.drawImage(bg, 0, 0, bg.naturalWidth, bg.naturalHeight, x, y, tw, th);
    }
  }
  
  ctx.restore();
}

// Render a bridge biome
function renderBridgeBiome(biome) {
  const config = {...TUNE.biomes.types.bridge.defaultConfig, ...biome.config};
  
  if(config.spriteSrc) {
    const bridgeImg = document.getElementById(getImageIdFromSrc(config.spriteSrc));
    if(isImageReady(bridgeImg)) {
      ctx.drawImage(bridgeImg, biome.x, biome.y, biome.w, biome.h);
      return;
    }
  }
  
  // Fallback rendering
  ctx.fillStyle = config.fallbackColor || '#8B4513';
  ctx.fillRect(biome.x, biome.y, biome.w, biome.h);
  ctx.strokeStyle = '#654321';
  ctx.lineWidth = 2;
  ctx.strokeRect(biome.x, biome.y, biome.w, biome.h);
}

// Helper to get image ID from sprite source path
function getImageIdFromSrc(src) {
  const mapping = {
    'sprites/backgrounds/zone_hollywood.png': 'bgHollywood',
    'sprites/backgrounds/zone_uptown.png': 'bgUptown',
    'sprites/backgrounds/zone_compton.png': 'bgCompton', 
    'sprites/backgrounds/zone_downtown.png': 'bgDowntown',
    'sprites/bridges/bridge_horizontal.png': 'bridgeHorizontal',
    'sprites/bridges/bridge_vertical.png': 'bridgeVertical'
  };
  return mapping[src] || src.split('/').pop().split('.')[0];
}

// -----------------------------
// Audio (procedural SFX + simple music)
// -----------------------------
let audioCtx=null, masterGain=null, sfxGain=null, musicGain=null;
const AudioSys={
  ensure(){ if(!audioCtx){ audioCtx=new (window.AudioContext||window.webkitAudioContext)(); masterGain=audioCtx.createGain(); sfxGain=audioCtx.createGain(); musicGain=audioCtx.createGain(); masterGain.gain.value=1; sfxGain.gain.value=settings.sfx; musicGain.gain.value=settings.music; sfxGain.connect(masterGain); musicGain.connect(masterGain); masterGain.connect(audioCtx.destination); /* procedural music disabled in favor of MP3 bgm */ } },
  beep(type='shoot', t=0){ if(!audioCtx) return; if(TUNE.sfx && TUNE.sfx.disableBeep) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.connect(g); g.connect(sfxGain);
    let f=440, dur=0.1;
    if(type==='shoot') { f=800; dur=0.07; }
    if(type==='hit') { f=200; dur=0.06; }
    if(type==='dash'){ f=600; dur=0.05; }
    if(type==='buy'){ f=500; dur=0.08; }
    if(type==='hurt'){ f=120; dur=0.12; }
    if(type==='death'){ f=60; dur=0.4; }
    if(type==='pickup'){ f=900; dur=0.06; }
    o.type='square';
    o.frequency.value=f; g.gain.value=.001; const now=audioCtx.currentTime+(t||0);
    g.gain.setValueAtTime(.18, now);
    g.gain.exponentialRampToValueAtTime(0.001, now+dur);
    o.start(now); o.stop(now+dur);
  },
  music(){ if(!audioCtx) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='sawtooth'; o.frequency.value=110; const lfo=audioCtx.createOscillator(); const lfoGain=audioCtx.createGain(); lfo.frequency.value=.25; lfoGain.gain.value=20; lfo.connect(lfoGain); lfoGain.connect(o.frequency); o.connect(g); g.connect(musicGain); g.gain.value=.03; o.start(); lfo.start(); }
};

// Simple MP3 loader/player
let sfxBuffers={};
async function loadSfx(name, url){ try{ if(!audioCtx) AudioSys.ensure(); const res=await fetch(url); const arr=await res.arrayBuffer(); const buf=await audioCtx.decodeAudioData(arr); sfxBuffers[name]=buf; }catch(e){ /* ignore */ } }
function playSfx(name, volumeMulOverride=1){ const el=document.getElementById('sfx_'+name); if(!el) return; const volMul=((TUNE.sfx?.volumes?.[name]??1) * (volumeMulOverride||1)); const inst=el.cloneNode(); inst.volume=Math.min(1,(settings.sfx||1)*(TUNE.sfx?.volume||1)*volMul); inst.play().catch(()=>{}); }

// Preload SFX on first user interaction
// no-op with <audio> tags; keep to initialize audio context for other beeps if needed
window.addEventListener('mousedown',()=>{ AudioSys.ensure(); },{once:true});

// -----------------------------
// Settings & Persistence
// -----------------------------
const LS_KEYS={LEGACY:'rw_legacy', BEST:'rw_best', SETTINGS:'rw_settings', SEED:'rw_seed'};
const defaultSettings={music:.15,sfx:.5,shake:true,dmgNums:true,reduceMotion:false,highContrast:false};
let settings = {...defaultSettings, ...JSON.parse(localStorage.getItem(LS_KEYS.SETTINGS)||'{}')};
let best = +(localStorage.getItem(LS_KEYS.BEST)||0);
let legacy = JSON.parse(localStorage.getItem(LS_KEYS.LEGACY)||'{}');
if(!legacy.totals){legacy={totals:{move:0, dmg:0, armor:0, luck:0, reload:0, lifesteal:0, hp:0}}}
setTxt('bestText', best);

// apply settings UI
$('#musicVol').value=settings.music; $('#sfxVol').value=settings.sfx; $('#shakeToggle').checked=settings.shake; $('#dmgNumToggle').checked=settings.dmgNums; $('#reduceMotion').checked=settings.reduceMotion; $('#highContrast').checked=settings.highContrast;
$('#musicVol').addEventListener('input', e=>{settings.music=+e.target.value; if(musicGain) musicGain.gain.value=settings.music; saveSettings();});
$('#sfxVol').addEventListener('input', e=>{settings.sfx=+e.target.value; if(sfxGain) sfxGain.gain.value=settings.sfx; saveSettings();});
$('#shakeToggle').addEventListener('change', e=>{settings.shake=e.target.checked; saveSettings();});
$('#dmgNumToggle').addEventListener('change', e=>{settings.dmgNums=e.target.checked; saveSettings();});
$('#reduceMotion').addEventListener('change', e=>{settings.reduceMotion=e.target.checked; saveSettings();});
$('#highContrast').addEventListener('change', e=>{settings.highContrast=e.target.checked; document.documentElement.style.setProperty('--accent', settings.highContrast?'#00ffe1':'#61dafb'); saveSettings();});
$('#closeSettings').onclick=()=>show('settings', false);
function saveSettings(){localStorage.setItem(LS_KEYS.SETTINGS, JSON.stringify(settings));}

// Seed
let storedSeed=localStorage.getItem(LS_KEYS.SEED); if(!storedSeed){storedSeed=''+Math.floor(Math.random()*1e9); localStorage.setItem(LS_KEYS.SEED, storedSeed);} R.reseed(hashStr(storedSeed));
$('#reseedBtn').onclick=()=>{const s=''+Math.floor(Math.random()*1e9); localStorage.setItem(LS_KEYS.SEED, s); R.reseed(hashStr(s)); AudioSys.ensure(); AudioSys.beep('pickup');};

// Music control (switch between normal and boss tracks)
let currentMusicEl = null;
function playMusic(el){ if(!el) return; const mul=(TUNE.sfx?.volumes?.bgm??1); el.volume=Math.min(1,(settings.music||0.5)*mul); el.currentTime=0; el.play().catch(()=>{}); currentMusicEl=el; }
function stopMusic(){ if(currentMusicEl){ try{ currentMusicEl.pause(); }catch(_){} } }
function switchToBossMusic(name){ stopMusic(); const el = document.getElementById(name==='Franklin'?'bgm_franklin':'bgm_trevor'); playMusic(el); }
function switchToNormalMusic(){ stopMusic(); playMusic(document.getElementById('bgm')); }
function switchToMenuMusic(){ stopMusic(); playMusic(document.getElementById('bgm_menu')); }

// Autoplay guard: start menu music on first gesture while in MENU
function isPlaying(el){ try{ return el && !el.paused && !el.ended && el.currentTime>0; }catch(_){ return false; } }
function ensureMenuMusicOnGesture(){ if(game.state===STATE.MENU){ const el=document.getElementById('bgm_menu'); if(!isPlaying(el)){ switchToMenuMusic(); } } }
window.addEventListener('pointerdown', ensureMenuMusicOnGesture);
window.addEventListener('keydown', ensureMenuMusicOnGesture);

// Legacy render
function renderLegacyPill(){const t=legacy.totals; setTxt('legacyText', `+${t.move*2}% move, +${t.dmg*2}% dmg, +${t.armor} ARM, +${t.luck*2}% luck`); setTxt('pLegacy', `move ${t.move*2}%, dmg ${t.dmg*2}%, armor ${t.armor}, luck ${t.luck*2}%`);} renderLegacyPill();
$('#resetLegacyBtn').onclick=()=>{if(confirm('Reset all legacy buffs?')){legacy={totals:{move:0,dmg:0,armor:0,luck:0,reload:0,lifesteal:0,hp:0}}; localStorage.setItem(LS_KEYS.LEGACY, JSON.stringify(legacy)); renderLegacyPill(); AudioSys.ensure(); AudioSys.beep('hurt');}}

// -----------------------------
// Canvas & Scaling
// -----------------------------
const cvs=$('#game'), ctx=cvs.getContext('2d');
const G={W:1600,H:900, scale:1};
function resize(){const w=window.innerWidth-12, h=window.innerHeight-12; const sx=w/G.W, sy=h/G.H; G.scale=Math.max(1, Math.floor(Math.min(sx, sy)) ); cvs.style.width=(G.W*G.scale)+'px'; cvs.style.height=(G.H*G.scale)+'px';}
window.addEventListener('resize', resize); resize();

// Camera & World (Stage 2 expansion)
const WORLD={W:G.W, H:G.H};
const camera={x:0,y:0,zoom:1, targetZoom:1, lock:false, follow:true, panTime:0, lerpSpeed:3};
function setWorldSize(w,h){ WORLD.W=w; WORLD.H=h; }
function worldToScreen(x,y){ return {x:(x - camera.x)*camera.zoom, y:(y - camera.y)*camera.zoom}; }
function getCameraBounds(viewW, viewH){
  if(inInterior && currentInterior && currentInterior.interior){
    const r=currentInterior.interior.rect;
    // For interiors, allow camera to show the whole room if it fits
    const minX = viewW >= r.w ? r.x + (r.w - viewW) / 2 : r.x;
    const maxX = viewW >= r.w ? minX : r.x + r.w - viewW;
    const minY = viewH >= r.h ? r.y + (r.h - viewH) / 2 : r.y;
    const maxY = viewH >= r.h ? minY : r.y + r.h - viewH;
    return {minX,maxX,minY,maxY};
  } else {
    const minX=0, minY=0;
    const maxX=Math.max(0, WORLD.W - viewW);
    const maxY=Math.max(0, WORLD.H - viewH);
    return {minX,maxX,minY,maxY};
  }
}
function centerCameraOn(x,y){ const viewW=G.W/Math.max(0.0001,camera.zoom), viewH=G.H/Math.max(0.0001,camera.zoom); const b=getCameraBounds(viewW, viewH); camera.x = clamp(x - viewW/2, b.minX, b.maxX); camera.y = clamp(y - viewH/2, b.minY, b.maxY); }
function updateCamera(dt){ const lerpAmt=clamp(dt*(camera.lerpSpeed||3),0,1); camera.zoom = camera.zoom + (camera.targetZoom - camera.zoom)*lerpAmt; const viewW=G.W/Math.max(0.0001,camera.zoom), viewH=G.H/Math.max(0.0001,camera.zoom); const b=getCameraBounds(viewW, viewH); if(camera.follow){ // side-scroll behavior
  const marginX = Math.min(260/camera.zoom, viewW*0.4), marginY = Math.min(200/camera.zoom, viewH*0.4);
  const left=camera.x+marginX, right=camera.x+viewW-marginX;
  const top=camera.y+marginY, bottom=camera.y+viewH-marginY;
  if(player.x<left) camera.x = Math.max(b.minX, player.x - marginX);
  if(player.x>right) camera.x = Math.min(b.maxX, player.x + marginX - viewW);
  if(player.y<top) camera.y = Math.max(b.minY, player.y - marginY);
  if(player.y>bottom) camera.y = Math.min(b.maxY, player.y + marginY - viewH);
} // ease to bounds if drifted
camera.x=clamp(camera.x,b.minX,b.maxX); camera.y=clamp(camera.y,b.minY,b.maxY); }

// Helpers for stage 2 tour
function fitZoomWholeWorld(){ const zx=G.W/Math.max(1,WORLD.W), zy=G.H/Math.max(1,WORLD.H); return Math.min(zx,zy)*0.98; }
function centerWorldViewAtCurrentZoom(){ camera.x = clamp(WORLD.W/2 - (G.W/(2*camera.zoom)), 0, Math.max(0, WORLD.W - G.W/camera.zoom)); camera.y = clamp(WORLD.H/2 - (G.H/(2*camera.zoom)), 0, Math.max(0, WORLD.H - G.H/camera.zoom)); }

// -----------------------------
// Input
// -----------------------------
const keys={}; const mouse={x:G.W/2,y:G.H/2,down:false,wheel:0};
window.addEventListener('keydown',e=>{keys[e.key.toLowerCase()]=true; if(e.key==='Escape'){togglePause();}});
window.addEventListener('keyup',e=>{keys[e.key.toLowerCase()]=false;});
// Skip current wave via equals key
window.addEventListener('keydown',e=>{ if(e.key==='=' && game.state===STATE.RUN && !game.intermission){ waveEnemies.length=0; enemies.forEach(en=>en.alive=false); endWave(); } });
// Skip directly to Stage 2 via Backspace
window.addEventListener('keydown',e=>{ if(e.key==='Backspace' && game.stage===1){ show('shop', false); enterStage2(); } });
cvs.addEventListener('mousemove',e=>{const r=cvs.getBoundingClientRect(); const sx=G.W/r.width, sy=G.H/r.height; const mx=(e.clientX-r.left)*sx; const my=(e.clientY-r.top)*sy; mouse.x = camera.x + mx / Math.max(0.0001, camera.zoom); mouse.y = camera.y + my / Math.max(0.0001, camera.zoom);});
cvs.addEventListener('mousedown',()=>{mouse.down=true; AudioSys.ensure();});
window.addEventListener('mouseup',()=>mouse.down=false);
cvs.addEventListener('wheel',e=>{mouse.wheel+=Math.sign(e.deltaY);});

// -----------------------------
// Game State
// -----------------------------
const STATE={MENU:0, RUN:1, PAUSE:2, SHOP:3, GAMEOVER:4, STAGE2:5};
let game={state:STATE.MENU, difficulty:0, wave:1, score:0, coins:0, time:0, intermission:false, dead:false, stage:1};

// Entities & Pools
const bullets=[], enemies=[], particles=[], drops=[]; // bullets include both player/enemy projectiles
let bulletPool=[], enemyPool=[], particlePool=[], dropPool=[];
let superCar={alive:false,x:0,y:0};
let parkedVehicles=[]; // {x,y,isSuper:true|false}
function getFrom(pool, create){for(let i=0;i<pool.length;i++){if(!pool[i].alive){pool[i].alive=true; return pool[i];}} const obj=create(); obj.alive=true; pool.push(obj); return obj;}

// ========================================
// GLOBAL TUNING CONFIG - Change values here to rebalance the game








// All gameplay-affecting numbers live in this object. Logic reads from here.
// ========================================
const TUNE = {
  difficulty: {
    playerSpeedMulHard: 1.05,
    enemySpeedMulHard: 1.25,
  },
  player: {
    radius: 8,
    baseSpeed: 130,
    startHp: 200,
    startArmor: 3,
    staminaMax: 100,
    dashCooldown: 1,
    dashCost: 10,
    dashDistance: 90,
    staminaRegenPerSec: 20,
    ammoReserve: 200,
    invincibleSecondsAfterMeleeHit: 0.5,
  },
  weapons: {
    pistol: { name:'Pistol', dmg:20, spread:2, rpm:240, projSpeed:340, mag:16, reload:1.0, type:'gun', projectile:true },
    smg:    { name:'SMG',    dmg:10,  spread:4, rpm:1000, projSpeed:320, mag:40, reload:1.2, type:'gun', projectile:true },
    shotgun:{ name:'Shotgun',dmg:8,  spread:10, rpm:70,  projSpeed:300, mag:6,  reload:1.4, pellets:6, type:'gun', projectile:true },
    rifle:  { name:'Rifle',  dmg:20, spread:2,  rpm:480, projSpeed:420, mag:30, reload:1.3, type:'gun', projectile:true },
    sniper: { name:'Sniper', dmg:60, spread:0,  rpm:60,  projSpeed:9999,mag:5,  reload:1.6, type:'gun', projectile:false, hitscan:true },
    rpg:    { name:'RPG',    dmg:120, spread:0, rpm:20,  projSpeed:100, mag:1,  reload:4.0, type:'gun', projectile:true, aoe:100, projRadius:10 },
    grapple:{ name:'Grapple', dmg:0,  spread:0, rpm:60,  projSpeed:700, mag:1,  reload:0.8, type:'gun', projectile:true, special:'grapple' },
    shortsword:{ name:'Crowbar', dmg:22, stamina:12, cooldown:.5, range:80, arc:1.1, type:'melee' },
    greatsword:{ name:'Baseball Bat', dmg:30, stamina:22, cooldown:.75, range:110, arc:1.2, type:'melee' },
    
    // SPECIAL GANG WEAPONS
    desert_eagle: { name:'Desert Eagle', dmg:45, spread:1, rpm:180, projSpeed:420, mag:8, reload:1.4, type:'gun', projectile:true, special:'gang_weapon', gang:'hollywood' },
    ak47: { name:'AK-47', dmg:35, spread:3, rpm:600, projSpeed:450, mag:30, reload:1.8, type:'gun', projectile:true, special:'gang_weapon', gang:'hollywood' },
    bolt_sniper: { name:'Bolt Action Sniper', dmg:300, spread:0, rpm:30, projSpeed:9999, mag:3, reload:2.5, type:'gun', projectile:false, hitscan:true, special:'gang_weapon', gang:'uptown' },
    compact_smg: { name:'Compact SMG', dmg:12, spread:3, rpm:1500, projSpeed:340, mag:50, reload:0.2, type:'gun', projectile:true, special:'gang_weapon', gang:'downtown' },
    double_shotgun: { name:'Double Pump Shotgun', dmg:16, spread:8, rpm:90, projSpeed:320, mag:2, reload:1.8, pellets:10, type:'gun', projectile:true, special:'gang_weapon', gang:'compton', doublePump:true },
  },
  enemies: {
    baseSpeed: { grunt:25, swarmer:50, tank:25 },
    radius: { default:8, tank:11 },
    hp: { grunt:54, swarmer:90, tank:300, shooter:100, rifler:100, smger:100, caster:100 },
    coinsPerKill: 3,
    moveWaveMul: { early:0.6, mid:0.65, lateBase:0.7, lateIncrement:0.001, lateCap:1 },
    preferDist: { min:140, max:220 },
    shootMaxRange: 280,
    strafeAmount: 30,
    retreatDistance: 30,
    approachDistance: 30,
    coverSeekHealthPct: 0.4,
    shootingCooldown: { smg:0.4, rifle:0.7, pistol:0.6 },
    meleeLeadTime: { early:0.06, mid:0.12, late:0.2 },
    meleeDamageMultiplier: 0.3,
    meleeStandOff: 10,
    maxSpeed: 80,
    speedRampTargetWave: 20,
    avoid: { radius: 15, weight: 1.6, ahead: 0.8 }
  ,
  },
  boss: {
    interval: 10,
    hp: 15000,
    speed: 20,
    radius: 26,
    color: '#ffcc33',
    coins: 50,
    patterns: {
      radialCount: 64,
      spiralInterval: 0.08,
      spiralArms: 8,
      wallRows: 3,
      wallSpacing: 60
    },
    bullet: { speed: 70, life: 3.0, radius: 3, spread: 0 },
    cooldowns: { big: 4.0, small: 0.08 },
    rocketSpeed: 60
  },
  spawn: {
    capWave2: 3,
    capWave4: 4,
    capBase: 8,
    capPer3Waves: 1,
    capMax: 10,
    intervalEarly: 0.7,
    intervalLate: 0.55,
    groupSizeEarly: 2,
    groupSizeLate: 4,
    groupArcSpreadDeg: 180,
    groupRadius: 180
  },
  waves: {
    early: { w1:{grunt:5}, w2:{grunt:5}, w3:{grunt:7, swarmer:2} },
    mid: { baseGrunt:5, swarmerAfterWave:4, shooterAfterWave:3 },
    late: { grunt:4, swarmer:4, smgerBase:3, riflerBase:2, tankAfterWave:7, scaleEvery:2 },
    endgame: { swarmer:6, smger:6, rifler:5, tank:3, casterEvery:2 },
  },
  obstacles: {
    mode: 'tile', // 'tile' uses background tile rects; 'random' uses random rectangles
    drawDebug: false,
    offsetX: -165,
    offsetY: 50,
    uniform: { enabled: true, wFrac: 0.25, hFrac: 0.325 },
    countMin: 8,
    countMax: 16,
    widthMin: 40,
    widthMax: 220,
    heightMin: 30,
    heightMax: 180,
    padding: 24,
    edgePadding: 40,
    attempts: 120
  },
  economy: {
    intermissionSeconds: 5,
    shopItemsPerWave: 3,
    prices: { smg:35, shotgun:40, rifle:45, armor:25, medkit:15, luck:20 },
    medkitHeal: 40,
  },
  drops: {
    coinDropBase: 0.45,
    coinDropPerLuck: 0.02,
    coinLifetime: 8,
  },
  scoring: { damageDivisor: 2 },
  fx: { hitLife:0.12, shakeHit:2, shakeHurt:3, floatVy:-18, floatLife:1, shakeDuration:0.15 },
  status: {
    burn: { duration: 4.0, dps: 3 },
    ice:  { duration: 5.0, slowMul: 0.5 },
    shock:{ duration: 2.0 },
    procChance: 0.30
  },
  legacy: {
    doubleDash:{name:'Blink Strider', step:1, cap:1, desc:'Gain double dash charges and shorter dash cooldown.'},
    carMaster:{name:'Interceptor', step:1, cap:1, desc:'Greatly boosts player vehicle HP, speed, and handling.'},
    specPistol:{name:'Pistolero', step:1, cap:1, desc:'Pistol specialist: +35% dmg, +25% RPM, +50% mag.'},
    specSmg:{name:'Bullet Hose', step:1, cap:1, desc:'SMG specialist: +25% dmg, +35% RPM, +40% mag.'},
    specShotgun:{name:'Street Sweeper', step:1, cap:1, desc:'Shotgun specialist: +40% dmg, +1 pellet, wider mag.'},
    specRifle:{name:'Marksman', step:1, cap:1, desc:'Rifle specialist: +30% dmg, +20% RPM, +40% mag.'},
    specSniper:{name:'Sharpshooter', step:1, cap:1, desc:'Sniper specialist: +50% dmg, faster rechamber, +2 mag.'},
    meleeMaster:{name:'Brawler', step:1, cap:1, desc:'Pure melee: +80% melee dmg, +40% melee range, +20% move speed.'},
    elemFire:{name:'Inferno Rounds', step:1, cap:1, desc:'Bullets turn red; ignite targets.'},
    elemIce:{name:'Cryo Rounds', step:1, cap:1, desc:'Bullets turn blue; slow targets.'},
    elemElectric:{name:'Shock Rounds', step:1, cap:1, desc:'Bullets turn gold; brief stun chance.'},
    grapplingHook:{name:'Grapple Gun', step:1, cap:1, desc:'New grappling gun; teleport to buildings you hook.'},
    luckyWheel:{name:'Fortune Hunter', step:1, cap:3, desc:'Greatly increases cars and coin drops: +50% coin per drop, +50% drop chance per rank; higher chance for car wrecks.'}
  },
  bullets: {
    friendlyRadius: 3,
    enemyRadius: 2.2,
    trailWidth: 1.25,
    trailAlpha: 0.55,
    impactLinger: 0.08,
    drawTrails: false,
    maxEnemyActive: 120,
       maxBossActive: 500,
       travelLifeMul: 3.5
  },
      background: { src: 'sprites/backgrounds/bg.png', alpha: 0.7, tileScale: 0.675, tileRects: [
      // Example rects per tile (fractions of tile width/height): buildings
      {x:0.08,y:0.05,w:0.32,h:0.38},
      {x:0.56,y:0.06,w:0.35,h:0.36},
      {x:0.17,y:0.52,w:0.3,h:0.37},
      {x:0.58,y:0.52,w:0.3,h:0.37}
    ] },
  sprites: {
    player: {
       // Update these filenames to your actual assets
             idle: 'sprites/characters/player_idle.png',
      left: 'sprites/characters/player_L.png',
      right: 'sprites/characters/player_R.png',
       // Per-sprite scales (override the base scale)
       scale: 0.225,
       scaleIdle: 0.125,
       scaleLeft: 0.075,
       scaleRight: 0.5,
       // Per-sprite Y offsets (optional)
       offsetY: -10,
       offsetIdleY: -10,
       offsetLeftY: -10,
       offsetRightY: -10,
       step: 0.12       // seconds per animation frame toggle
     },
     enemy: {
       grunt: {
                 idle: 'sprites/enemies/grunt_idle.png',
        left: 'sprites/enemies/grunt_L.png',
        right: 'sprites/enemies/grunt_R.png',
         scale: 0.225,
         scaleIdle: 0.5,
         scaleLeft: 0.5,
         scaleRight: 0.5,
         offsetY: -8,
         step: 0.14
       },
       swarmer: {
                 idle: 'sprites/enemies/swarmer_idle.png',
        left: 'sprites/enemies/swarmer_L.png',
        right: 'sprites/enemies/swarmer_R.png',
        up: 'sprites/enemies/swarmer_U.png',
        down: 'sprites/enemies/swarmer_D.png',
         scale: 1.35,
         offsetY: -8
       },
       tank: {
                 idle: 'sprites/enemies/tank_idle.png',
        left: 'sprites/enemies/tank_L.png',
        right: 'sprites/enemies/tank_R.png',
        up: 'sprites/enemies/tank_U.png',
        down: 'sprites/enemies/tank_D.png',
         scale: 0.6,
         offsetY: -10
       },
             boss: { scale: 0.1, offsetY: -12 },
      
      // Quest Boss Animation Settings
      questBoss: {
        scale: 0.3,
        offsetY: -12,
        step: 0.3  // Animation speed (seconds per frame) - tunable for left/right animation rate
      }
    },
        bag: { image: 'sprites/items/money_bag.png', scale: 0.2 }
  },
  sfx: {
    volume: 0.9,             // master SFX volume multiplier
    disableBeep: true,
    files: {
      pistol: 'pistol.mp3',
      rifle: 'rifle.mp3',
      smg: 'smg.mp3',
      shotgun: 'shotgun.mp3',
      rpg_fire: 'rpg_fire.mp3',
      rpg_explosion: 'rpg_explosion.mp3'
    },
    volumes: {               // per-sound fine-tuning
      pistol: 0.8,
      rifle: 0.8,
      smg: 0.7,
      shotgun: 0.8,
      rpg_fire: 0.7,
      rpg_explosion: 0.7,
      bgm: 1.3
    },
    bgm: 'bgm.mp3'
  },
  vehicle: {
    hp: 50,            // temporary car HP
    speedMul: 1.75,      // speed multiplier while in vehicle
    radius: 12,         // collision radius while in vehicle
          sprite: 'sprites/vehicles/copcar_player.png',
      wreck: 'sprites/vehicles/copcar_wreck.png',
    scale: 0.85,
    offsetY: -6,
    dropLife: 15        // seconds the wreck pickup remains
  },
      superCar: {
      hp: 140,
      speedMul: 4.8,
      radius: 12,
      sprite: 'sprites/vehicles/super_car_idle.png',
      scale: 1.4,
      offsetY: -4,
    },
    ferrari: {
      hp: 120,
      speedMul: 6.0, // 50% faster than super car
      radius: 11,
      sprite: 'sprites/vehicles/ferrari_idle.png',
      scale: 1.3,
      offsetY: -4,
    },
    armoredVan: {
      hp: 420, // 3x super car health
      speedMul: 3.2, // Slower than super car
      radius: 14,
      sprite: 'sprites/vehicles/armored_van_idle.png',
      scale: 1.5,
      offsetY: -4,
    },
  
  // ========================================
  // CAMERA SYSTEM - Configure camera behavior and zoom levels
  // ========================================
  camera: {
    // Stage-specific zoom levels
    stage1Zoom: 1.0,      // Camera zoom for Stage 1 (normal view)
    stage2Zoom: 0.4,      // Camera zoom for Stage 2 (zoomed out for larger world)
    
    // Transition settings
    transitionZoom: {
      enabled: true,      // Whether to use zoom transitions
      speed: 0.3,         // Zoom transition speed (lower = slower)
      tourSpeed: 4      // Speed during Stage 2 camera tour
    },
    
    // Interior zoom settings
    interiorZoom: {
      autoFit: true,      // Automatically fit camera to interior size
      padding: 1.2        // Extra space around interior (1.0 = exact fit, 1.2 = 20% padding)
    }
  },
  enemyGuns: {
    shotgun: { pellets:6, spread:28, speed:90,  dmg:7, life:1.2 },
    rifle:   { speed:90,  dmg:8,  life:1.8, spread:8,  count:3 },
    smg:     { speed:100, dmg:3,  life:1.5, spread:14, count:5 },
    pistol:  { speed:80,  dmg:6,  life:1.6, spread:9,  count:3 },
  },
  
  // ========================================
  // BIOME SYSTEM - Configure map layout and biome placement
  // ========================================
  biomes: {
    // Biome instances - each can be placed anywhere and resized
    instances: [
      // Center borough (expanded to fill space between rivers and bottom edge)
      {
        id: 'center_borough',
        type: 'borough',
        x: 4800,  // Flush with river_west end
        y: 4050,  // Flush with river_north end
        w: 6200,  // From river_west to river_east (4800 to 11200)
        h: 5950,  // From river_north to map bottom (4050 to 10000)
        config: {
          backgroundSrc: 'sprites/backgrounds/bg.png',
          tileScale: 0.675,
          tileDensity: 1.0,  // 1.0 = normal density, 2.0 = 4x more tiles, 0.5 = 1/4 tiles
          hasObstacles: true,
          obstacleOffset: { x: -165, y: 50 }
        }
      },
      
      // North borough (fills space between rivers above river_north)
      {
        id: 'north_borough',
        type: 'borough',
        x: 4800,  // Flush with river_west end
        y: 0,     // Flush with map top
        w: 6200,  // From river_west to river_east (4800 to 11200)
        h: 3300,  // From map top to river_north (0 to 3500)
        config: {
          backgroundSrc: 'sprites/backgrounds/bg.png',
          tileScale: 0.675,
          tileDensity: 1.0,  // 1.0 = normal density, 2.0 = 4x more tiles, 0.5 = 1/4 tiles
          hasObstacles: true,
          obstacleOffset: { x: -165, y: 50 }
        }
      },
      
      // Hollywood zone (top-left) - flush with map boundary and river_west
      {
        id: 'hollywood_zone',
        type: 'zone',
        x: 0,    // Flush with map boundary
        y: 0,    // Flush with map boundary  
        w: 4000, // Flush with river_west
        h: 3500, // Flush with river_north
        config: {
          backgroundSrc: 'sprites/backgrounds/zone_hollywood.png',
          tileDensity: 1.0,  // 1.0 = normal density, 2.0 = 4x more tiles, 0.5 = 1/4 tiles
          zoneName: 'Hollywood',
          gangData: 'hollywood',
          buildingCount: 2, // HQ + Shop
          obstacleCount: 14
        }
      },
      
      // Uptown zone (top-right) - flush with river_east and map boundary
      {
        id: 'uptown_zone',
        type: 'zone',
        x: 12000, // Flush with river_east end
        y: 0,     // Flush with map boundary
        w: 4000,  // Flush with map boundary (assuming 16000 total width)
        h: 3500,  // Flush with river_north
        config: {
          backgroundSrc: 'sprites/backgrounds/zone_uptown.png',
          tileDensity: 1.0,  // 1.0 = normal density, 2.0 = 4x more tiles, 0.5 = 1/4 tiles
          zoneName: 'Uptown',
          gangData: 'uptown',
          buildingCount: 2,
          obstacleCount: 14
        }
      },
      
      // Compton zone (bottom-left) - flush with map boundary and river_west
      {
        id: 'compton_zone',
        type: 'zone',
        x: 0,    // Flush with map boundary
        y: 4050, // Flush with river_north end
        w: 4000, // Flush with river_west
        h: 5950, // Flush with map boundary (assuming 10000 total height)
        config: {
          backgroundSrc: 'sprites/backgrounds/zone_compton.png',
          tileDensity: 1.0,  // 1.0 = normal density, 2.0 = 4x more tiles, 0.5 = 1/4 tiles
          zoneName: 'Compton',
          gangData: 'compton',
          buildingCount: 2,
          obstacleCount: 14
        }
      },
      
      // Downtown zone (bottom-right) - flush with river_east and map boundary
      {
        id: 'downtown_zone',
        type: 'zone',
        x: 12000, // Flush with river_east end
        y: 4050,  // Flush with river_north end
        w: 4000,  // Flush with map boundary
        h: 5950,  // Flush with map boundary
        config: {
          backgroundSrc: 'sprites/backgrounds/zone_downtown.png',
          tileDensity: 1.0,  // 1.0 = normal density, 2.0 = 4x more tiles, 0.5 = 1/4 tiles
          zoneName: 'Downtown',
          gangData: 'downtown',
          buildingCount: 2,
          obstacleCount: 14
        }
      },
      
      // Horizontal rivers (separating top/bottom)
      {
        id: 'river_north',
        type: 'river',
        x: 0,
        y: 3500,
        w: 16000,
        h: 550,
        config: {
          flowDirection: 'horizontal',
          waterColor: '#1e3a5f',
          textureColor: '#2a4f7a'
        }
      },
      
      // Vertical rivers (separating left/right)
      {
        id: 'river_west',
        type: 'river',
        x: 4000,
        y: 0,
        w: 800,
        h: 10000,
        config: {
          flowDirection: 'vertical',
          waterColor: '#1e3a5f',
          textureColor: '#2a4f7a'
        }
      },
      
      {
        id: 'river_east',
        type: 'river',
        x: 11200,
        y: 0,
        w: 800,
        h: 10000,
        config: {
          flowDirection: 'vertical',
          waterColor: '#1e3a5f',
          textureColor: '#2a4f7a'
        }
      },

      
      // Bridges connecting zones
      {
        id: 'bridge_north_center',
        type: 'bridge',
        x: 7700,
        y: 3400,
        w: 200,
        h: 700,
        config: {
          direction: 'vertical',
          spriteSrc: 'sprites/bridges/bridge_vertical.png'
        }
      },

      {
        id: 'bridge_uptown_downtown',
        type: 'bridge',
        x: 14000,
        y: 3400,
        w: 200,
        h: 700,
        config: {
          direction: 'vertical',
          spriteSrc: 'sprites/bridges/bridge_vertical.png'
        }
      },

      {
        id: 'bridge_hollywood_compton',
        type: 'bridge',
        x: 2000,
        y: 3400,
        w: 200,
        h: 700,
        config: {
          direction: 'vertical',
          spriteSrc: 'sprites/bridges/bridge_vertical.png'
        }
      },

      {
        id: 'bridge_north_hollywood',
        type: 'bridge',
        x: 3900,
        y: 1400,
        w: 900,
        h: 200,
        config: {
          direction: 'horizontal',
          spriteSrc: 'sprites/bridges/bridge_horizontal.png'
        }
      },

      {
        id: 'bridge_north_uptown',
        type: 'bridge',
        x: 11100,
        y: 1400,
        w: 900,
        h: 200,
        config: {
          direction: 'horizontal',
          spriteSrc: 'sprites/bridges/bridge_horizontal.png'
        }
      },

      {
        id: 'bridge_west_center',
        type: 'bridge',
        x: 3900,
        y: 4400,
        w: 900,
        h: 200,
        config: {
          direction: 'horizontal',
          spriteSrc: 'sprites/bridges/bridge_horizontal.png'
        }
      },
      
      {
        id: 'bridge_east_center',
        type: 'bridge',
        x: 11100,
        y: 4400,
        w: 900,
        h: 200,
        config: {
          direction: 'horizontal',
          spriteSrc: 'sprites/bridges/bridge_horizontal.png'
        }
      }
    ],
    
    // Biome type definitions
    types: {
      borough: {
        description: 'Original Stage 1 city center with tiled background and obstacles',
        defaultConfig: {
          backgroundSrc: 'sprites/backgrounds/bg.png',
          tileScale: 0.675,
          tileDensity: 1.0,  // 1.0 = normal density, 2.0 = 4x more tiles, 0.5 = 1/4 tiles
          alpha: 0.7,
          hasObstacles: true,
          obstacleOffset: { x: 0, y: 0 }
        }
      },
      
      zone: {
        description: 'Gang territory zones with unique backgrounds and buildings',
        defaultConfig: {
          backgroundSrc: null,
          tileDensity: 1.0,  // 1.0 = normal density, 2.0 = 4x more tiles, 0.5 = 1/4 tiles
          alpha: 0.8,
          obstacleCount: 14,
          buildingCount: 2,
          gangData: null
        }
      },
      
      river: {
        description: 'Water barriers that block movement unless on bridges',
        defaultConfig: {
          waterColor: '#1e3a5f',
          textureColor: '#2a4f7a',
          textureSize: 8,
          flowDirection: 'horizontal'
        }
      },
      
      bridge: {
        description: 'Passable structures over rivers connecting different areas',
        defaultConfig: {
          spriteSrc: null,
          direction: 'horizontal',
          fallbackColor: '#8B4513'
                 }
       }
     }
   },
   
   // ========================================
   // OBSTACLES SYSTEM - Configure every obstacle manually
   // ========================================
   obstacles: {
     // Manual obstacle instances - each obstacle can be placed anywhere
     instances: [
       // Center borough obstacles (distributed across expanded area)
       {id: 'center_borough_1', x: 5200, y: 4300, w: 120, h: 80, biome: 'center_borough'},
       {id: 'center_borough_2', x: 5800, y: 4600, w: 100, h: 90, biome: 'center_borough'},
       {id: 'center_borough_3', x: 6400, y: 4900, w: 130, h: 85, biome: 'center_borough'},
       {id: 'center_borough_4', x: 7000, y: 5200, w: 110, h: 75, biome: 'center_borough'},
       {id: 'center_borough_5', x: 7600, y: 5500, w: 95, h: 95, biome: 'center_borough'},
       {id: 'center_borough_6', x: 8200, y: 5800, w: 140, h: 70, biome: 'center_borough'},
       {id: 'center_borough_7', x: 8800, y: 6100, w: 105, h: 100, biome: 'center_borough'},
       {id: 'center_borough_8', x: 9400, y: 6400, w: 125, h: 80, biome: 'center_borough'},
       {id: 'center_borough_9', x: 10000, y: 6700, w: 180, h: 100, biome: 'center_borough'},
       {id: 'center_borough_10', x: 5500, y: 7000, w: 160, h: 110, biome: 'center_borough'},
       {id: 'center_borough_11', x: 6100, y: 7300, w: 170, h: 140, biome: 'center_borough'},
       {id: 'center_borough_12', x: 6700, y: 7600, w: 150, h: 100, biome: 'center_borough'},
       {id: 'center_borough_13', x: 7300, y: 7900, w: 190, h: 120, biome: 'center_borough'},
       {id: 'center_borough_14', x: 7900, y: 8200, w: 160, h: 130, biome: 'center_borough'},
       {id: 'center_borough_15', x: 8500, y: 8500, w: 140, h: 90, biome: 'center_borough'},
       {id: 'center_borough_16', x: 9100, y: 8800, w: 200, h: 120, biome: 'center_borough'},
       
       // North borough obstacles 
       {id: 'north_borough_1', x: 5200, y: 800, w: 120, h: 80, biome: 'north_borough'},
       {id: 'north_borough_2', x: 5500, y: 1200, w: 100, h: 90, biome: 'north_borough'},
       {id: 'north_borough_3', x: 5800, y: 1600, w: 130, h: 85, biome: 'north_borough'},
       {id: 'north_borough_4', x: 6100, y: 1000, w: 110, h: 75, biome: 'north_borough'},
       {id: 'north_borough_5', x: 6400, y: 1400, w: 95, h: 95, biome: 'north_borough'},
       {id: 'north_borough_6', x: 6700, y: 1800, w: 140, h: 70, biome: 'north_borough'},
       {id: 'north_borough_7', x: 7000, y: 1200, w: 105, h: 100, biome: 'north_borough'},
       {id: 'north_borough_8', x: 7300, y: 1600, w: 125, h: 80, biome: 'north_borough'},
       {id: 'north_borough_9', x: 7600, y: 2000, w: 180, h: 100, biome: 'north_borough'},
       {id: 'north_borough_10', x: 7900, y: 2400, w: 160, h: 110, biome: 'north_borough'},
       {id: 'north_borough_11', x: 8200, y: 2800, w: 170, h: 140, biome: 'north_borough'},
       {id: 'north_borough_12', x: 8500, y: 3000, w: 150, h: 100, biome: 'north_borough'},
       
       // Hollywood zone obstacles (now flush with map boundary and river_west)
       {id: 'hollywood_obstacle_1', x: 200, y: 200, w: 180, h: 120, biome: 'hollywood_zone'},
       {id: 'hollywood_obstacle_2', x: 500, y: 400, w: 160, h: 100, biome: 'hollywood_zone'},
       {id: 'hollywood_obstacle_3', x: 800, y: 600, w: 200, h: 140, biome: 'hollywood_zone'},
       {id: 'hollywood_obstacle_4', x: 1100, y: 300, w: 170, h: 110, biome: 'hollywood_zone'},
       {id: 'hollywood_obstacle_5', x: 1400, y: 700, w: 150, h: 130, biome: 'hollywood_zone'},
       {id: 'hollywood_obstacle_6', x: 1700, y: 500, w: 190, h: 90, biome: 'hollywood_zone'},
       {id: 'hollywood_obstacle_7', x: 2000, y: 900, w: 140, h: 120, biome: 'hollywood_zone'},
       {id: 'hollywood_obstacle_8', x: 2300, y: 200, w: 160, h: 150, biome: 'hollywood_zone'},
       {id: 'hollywood_obstacle_9', x: 2600, y: 1000, w: 180, h: 100, biome: 'hollywood_zone'},
       {id: 'hollywood_obstacle_10', x: 2900, y: 1300, w: 200, h: 110, biome: 'hollywood_zone'},
       {id: 'hollywood_obstacle_11', x: 3200, y: 1600, w: 170, h: 140, biome: 'hollywood_zone'},
       {id: 'hollywood_obstacle_12', x: 3500, y: 1200, w: 150, h: 100, biome: 'hollywood_zone'},
       {id: 'hollywood_obstacle_13', x: 3800, y: 2500, w: 190, h: 120, biome: 'hollywood_zone'},
       {id: 'hollywood_obstacle_14', x: 400, y: 2800, w: 160, h: 130, biome: 'hollywood_zone'},
       
       // Uptown zone obstacles (now flush with river_east and map boundary)
       {id: 'uptown_obstacle_1', x: 12200, y: 200, w: 180, h: 120, biome: 'uptown_zone'},
       {id: 'uptown_obstacle_2', x: 12500, y: 400, w: 160, h: 100, biome: 'uptown_zone'},
       {id: 'uptown_obstacle_3', x: 12800, y: 600, w: 200, h: 140, biome: 'uptown_zone'},
       {id: 'uptown_obstacle_4', x: 13100, y: 300, w: 170, h: 110, biome: 'uptown_zone'},
       {id: 'uptown_obstacle_5', x: 13400, y: 700, w: 150, h: 130, biome: 'uptown_zone'},
       {id: 'uptown_obstacle_6', x: 13700, y: 500, w: 190, h: 90, biome: 'uptown_zone'},
       {id: 'uptown_obstacle_7', x: 14000, y: 900, w: 140, h: 120, biome: 'uptown_zone'},
       {id: 'uptown_obstacle_8', x: 14300, y: 200, w: 160, h: 150, biome: 'uptown_zone'},
       {id: 'uptown_obstacle_9', x: 14600, y: 1000, w: 180, h: 100, biome: 'uptown_zone'},
       {id: 'uptown_obstacle_10', x: 14900, y: 1300, w: 200, h: 110, biome: 'uptown_zone'},
       {id: 'uptown_obstacle_11', x: 15200, y: 1600, w: 170, h: 140, biome: 'uptown_zone'},
       {id: 'uptown_obstacle_12', x: 15500, y: 1200, w: 150, h: 100, biome: 'uptown_zone'},
       {id: 'uptown_obstacle_13', x: 15800, y: 2500, w: 190, h: 120, biome: 'uptown_zone'},
       {id: 'uptown_obstacle_14', x: 12400, y: 2800, w: 160, h: 130, biome: 'uptown_zone'},
       
       // Compton zone obstacles (now flush with map boundary and river_west)
       {id: 'compton_obstacle_1', x: 200, y: 4200, w: 180, h: 120, biome: 'compton_zone'},
       {id: 'compton_obstacle_2', x: 500, y: 4400, w: 160, h: 100, biome: 'compton_zone'},
       {id: 'compton_obstacle_3', x: 800, y: 4600, w: 200, h: 140, biome: 'compton_zone'},
       {id: 'compton_obstacle_4', x: 1100, y: 4300, w: 170, h: 110, biome: 'compton_zone'},
       {id: 'compton_obstacle_5', x: 1400, y: 4700, w: 150, h: 130, biome: 'compton_zone'},
       {id: 'compton_obstacle_6', x: 1700, y: 4500, w: 190, h: 90, biome: 'compton_zone'},
       {id: 'compton_obstacle_7', x: 2000, y: 4900, w: 140, h: 120, biome: 'compton_zone'},
       {id: 'compton_obstacle_8', x: 2300, y: 4200, w: 160, h: 150, biome: 'compton_zone'},
       {id: 'compton_obstacle_9', x: 2600, y: 5000, w: 180, h: 100, biome: 'compton_zone'},
       {id: 'compton_obstacle_10', x: 2900, y: 5300, w: 200, h: 110, biome: 'compton_zone'},
       {id: 'compton_obstacle_11', x: 3200, y: 5600, w: 170, h: 140, biome: 'compton_zone'},
       {id: 'compton_obstacle_12', x: 3500, y: 5200, w: 150, h: 100, biome: 'compton_zone'},
       {id: 'compton_obstacle_13', x: 3800, y: 6500, w: 190, h: 120, biome: 'compton_zone'},
       {id: 'compton_obstacle_14', x: 400, y: 6800, w: 160, h: 130, biome: 'compton_zone'},
       
       // Downtown zone obstacles (now flush with river_east and map boundary)
       {id: 'downtown_obstacle_1', x: 12200, y: 4200, w: 180, h: 120, biome: 'downtown_zone'},
       {id: 'downtown_obstacle_2', x: 12500, y: 4400, w: 160, h: 100, biome: 'downtown_zone'},
       {id: 'downtown_obstacle_3', x: 12800, y: 4600, w: 200, h: 140, biome: 'downtown_zone'},
       {id: 'downtown_obstacle_4', x: 13100, y: 4300, w: 170, h: 110, biome: 'downtown_zone'},
       {id: 'downtown_obstacle_5', x: 13400, y: 4700, w: 150, h: 130, biome: 'downtown_zone'},
       {id: 'downtown_obstacle_6', x: 13700, y: 4500, w: 190, h: 90, biome: 'downtown_zone'},
       {id: 'downtown_obstacle_7', x: 14000, y: 4900, w: 140, h: 120, biome: 'downtown_zone'},
       {id: 'downtown_obstacle_8', x: 14300, y: 4200, w: 160, h: 150, biome: 'downtown_zone'},
       {id: 'downtown_obstacle_9', x: 14600, y: 5000, w: 180, h: 100, biome: 'downtown_zone'},
       {id: 'downtown_obstacle_10', x: 14900, y: 5300, w: 200, h: 110, biome: 'downtown_zone'},
       {id: 'downtown_obstacle_11', x: 15200, y: 5600, w: 170, h: 140, biome: 'downtown_zone'},
       {id: 'downtown_obstacle_12', x: 15500, y: 5200, w: 150, h: 100, biome: 'downtown_zone'},
       {id: 'downtown_obstacle_13', x: 15800, y: 6500, w: 190, h: 120, biome: 'downtown_zone'},
       {id: 'downtown_obstacle_14', x: 12400, y: 6800, w: 160, h: 130, biome: 'downtown_zone'}
     ],
     
     // Generation settings for when automatic generation is used
     generation: {
       enabled: false, // Set to true to use automatic generation instead of manual
       boroughTileMode: true, // Use tile-based obstacles for borough
       zoneRandomMode: true, // Use random obstacles for zones
       padding: 40,
       edgePadding: 40,
       attempts: 120
     }
   },
   
   // ========================================
   // BUILDINGS SYSTEM - Configure every building manually
   // ========================================
   buildings: {
     // Manual building instances - each building can be placed anywhere
     instances: [
       // Hollywood zone buildings (new zone: x: 0, y: 0, w: 4000, h: 3500)
       {
         id: 'hollywood_hq',
         type: 'hq',
         x: 1890, // Center of new Hollywood zone
         y: 1670,
         w: 220,
         h: 160,
         door: {x: 1970, y: 1814, w: 60, h: 16},
         biome: 'hollywood_zone',
         gang: 'hollywood',
         config: {
           npcType: 'gang_leader',
           interiorSize: {w: 800, h: 600},
           interiorObstacles: 8
         }
       },
       {
         id: 'hollywood_shop',
         type: 'shop', 
         x: 2120,
         y: 1670,
         w: 180,
         h: 140,
         door: {x: 2185, y: 1794, w: 50, h: 16},
         biome: 'hollywood_zone',
         gang: 'hollywood',
         config: {
           npcType: 'shopkeeper',
           interiorSize: {w: 600, h: 500},
           interiorObstacles: 5
         }
       },
       
       // Uptown zone buildings (new zone: x: 12000, y: 0, w: 4000, h: 3500)
       {
         id: 'uptown_hq',
         type: 'hq',
         x: 13890, // Center of new Uptown zone
         y: 1670,
         w: 220,
         h: 160,
         door: {x: 13970, y: 1814, w: 60, h: 16},
         biome: 'uptown_zone',
         gang: 'uptown',
         config: {
           npcType: 'gang_leader',
           interiorSize: {w: 800, h: 600},
           interiorObstacles: 8
         }
       },
       {
         id: 'uptown_shop',
         type: 'shop',
         x: 14120,
         y: 1670,
         w: 180,
         h: 140,
         door: {x: 14185, y: 1794, w: 50, h: 16},
         biome: 'uptown_zone',
         gang: 'uptown',
         config: {
           npcType: 'shopkeeper',
           interiorSize: {w: 600, h: 500},
           interiorObstacles: 5
         }
       },
       
       // Compton zone buildings (new zone: x: 0, y: 4050, w: 4000, h: 5950)
       {
         id: 'compton_hq',
         type: 'hq',
         x: 1890, // Center of new Compton zone
         y: 7000, // Center vertically in zone 
         w: 220,
         h: 160,
         door: {x: 1970, y: 7144, w: 60, h: 16},
         biome: 'compton_zone',
         gang: 'compton',
         config: {
           npcType: 'gang_leader',
           interiorSize: {w: 800, h: 600},
           interiorObstacles: 8
         }
       },
       {
         id: 'compton_shop',
         type: 'shop',
         x: 2120,
         y: 7000,
         w: 180,
         h: 140,
         door: {x: 2185, y: 7124, w: 50, h: 16},
         biome: 'compton_zone',
         gang: 'compton',
         config: {
           npcType: 'shopkeeper',
           interiorSize: {w: 600, h: 500},
           interiorObstacles: 5
         }
       },
       
       // Downtown zone buildings (new zone: x: 12000, y: 4050, w: 4000, h: 5950)
       {
         id: 'downtown_hq',
         type: 'hq',
         x: 13890, // Center of new Downtown zone
         y: 7000,  // Center vertically in zone
         w: 220,
         h: 160,
         door: {x: 13970, y: 7144, w: 60, h: 16},
         biome: 'downtown_zone',
         gang: 'downtown',
         config: {
           npcType: 'gang_leader',
           interiorSize: {w: 800, h: 600},
           interiorObstacles: 8
         }
       },
       {
         id: 'downtown_shop',
         type: 'shop',
         x: 14120,
         y: 7000,
         w: 180,
         h: 140,
         door: {x: 14185, y: 7124, w: 50, h: 16},
         biome: 'downtown_zone',
         gang: 'downtown',
         config: {
           npcType: 'shopkeeper',
           interiorSize: {w: 600, h: 500},
           interiorObstacles: 5
         }
       },
       
       // Quest Buildings - Larger buildings for boss fights, further from HQs
       {
         id: 'hollywood_quest',
         type: 'quest',
         x: 800, // West side of Hollywood
         y: 1200,
         w: 300,
         h: 200,
         door: {x: 920, y: 1384, w: 60, h: 16},
         biome: 'hollywood_zone',
         gang: 'hollywood',
         config: {
           npcType: 'quest_boss',
           bossType: 'sex_trafficker',
           interiorSize: {w: 1000, h: 800},
           interiorObstacles: 12,
           enemyCount: 8
         }
       },
       {
         id: 'uptown_quest', 
         type: 'quest',
         x: 15200, // East side of Uptown
         y: 1200,
         w: 300,
         h: 200,
         door: {x: 15320, y: 1384, w: 60, h: 16},
         biome: 'uptown_zone',
         gang: 'uptown',
         config: {
           npcType: 'quest_boss',
           bossType: 'rainbow_hippie',
           interiorSize: {w: 1000, h: 800},
           interiorObstacles: 12,
           enemyCount: 8
         }
       },
       {
         id: 'compton_quest',
         type: 'quest',
         x: 1600, // South side of Compton
         y: 6200,
         w: 300,
         h: 200,
         door: {x: 1720, y: 6384, w: 60, h: 16},
         biome: 'compton_zone',
         gang: 'compton',
         config: {
           npcType: 'quest_boss',
           bossType: 'chain_snatcher',
           interiorSize: {w: 1000, h: 800},
           interiorObstacles: 12,
           enemyCount: 8
         }
       },
       {
         id: 'downtown_quest',
         type: 'quest',
         x: 14400, // North side of Downtown 
         y: 5400,
         w: 300,
         h: 200,
         door: {x: 14520, y: 5584, w: 60, h: 16},
         biome: 'downtown_zone',
         gang: 'downtown',
         config: {
           npcType: 'quest_boss',
           bossType: 'fake_king',
           interiorSize: {w: 1000, h: 800},
           interiorObstacles: 12,
           enemyCount: 8
         }
       }
     ],
     
     // Generation settings for when automatic generation is used
     generation: {
       enabled: false, // Set to true to use automatic generation instead of manual
       buildingsPerZone: 2, // HQ + Shop
       hqSize: {w: 220, h: 160},
       shopSize: {w: 180, h: 140},
       spacing: 120, // Distance between HQ and shop
       doorSize: {hq: {w: 60, h: 16}, shop: {w: 50, h: 16}}
     }
   }
};

// ========================================
// PLAYER STATS & ATTRIBUTES - TUNE THESE VALUES
// ========================================
// TUNE: Player base stats - modify these to change player power level
const player={
  x:G.W/2, y:G.H/2, r:TUNE.player.radius,
  vx:0, vy:0,
  speed:TUNE.player.baseSpeed,
  hp:TUNE.player.startHp, hpMax:TUNE.player.startHp,
  armor:TUNE.player.startArmor,
  stamina:TUNE.player.staminaMax, staminaMax:TUNE.player.staminaMax,
  dashCD:0, dashMax:TUNE.player.dashCooldown,
  facing:0,
  weaponIndex:0, weapons:[], secondary:null, inv:[],
  reloadTimer:0, reloading:false,
  ammoReserve:TUNE.player.ammoReserve,
  iframes:0,
  // vehicle state
  inVehicle:false,
  vehicleHp:0,
  // anim state
  animDir:'idle', // 'idle' | 'left' | 'right'
  animOn:false,
  animT:0,
  animPhase:false,
  // grappling state
  grappling:false,
  grappleX:0, grappleY:0,
  grappleBullet:null,
  grappleRopePts:[]
};

// Obstacles
const obstacles=[]; // procedurally generated

function buildTileObstacles(){
  const bg = document.getElementById('bgImg');
  if(!bg || !bg.complete || !(bg.naturalWidth>0 && bg.naturalHeight>0)) return false;
  const scale = TUNE.background.tileScale || 1;
  const tw = Math.max(8, Math.floor((bg.naturalWidth||256) * scale));
  const th = Math.max(8, Math.floor((bg.naturalHeight||256) * scale));
  const rects = TUNE.background.tileRects || [];
  obstacles.length=0;
  for(let y=0;y<G.H;y+=th){
    for(let x=0;x<G.W;x+=tw){
      for(const r of rects){
        const ox = x + Math.floor(r.x*tw) + (TUNE.obstacles.offsetX||0);
        const oy = y + Math.floor(r.y*th) + (TUNE.obstacles.offsetY||0);
        const Uw = (TUNE.obstacles.uniform && TUNE.obstacles.uniform.enabled) ? Math.floor((TUNE.obstacles.uniform.wFrac||r.w)*tw) : Math.floor(r.w*tw);
        const Uh = (TUNE.obstacles.uniform && TUNE.obstacles.uniform.enabled) ? Math.floor((TUNE.obstacles.uniform.hFrac||r.h)*th) : Math.floor(r.h*th);
        const ow = Uw;
        const oh = Uh;
        obstacles.push({x:ox,y:oy,w:ow,h:oh});
      }
    }
  }
  return true;
}

function genObstacles(){
  obstacles.length=0;
  const C=TUNE.obstacles;
  if(C.mode==='tile'){
    const ok=buildTileObstacles();
    if(ok) return;
  }
  const n = R.rint(C.countMin, C.countMax);
  let tries=0;
  while(obstacles.length<n && tries++<C.attempts){
    const w = R.rint(C.widthMin, C.widthMax);
    const h = R.rint(C.heightMin, C.heightMax);
    const x = R.rint(C.edgePadding, G.W - C.edgePadding - w);
    const y = R.rint(C.edgePadding, G.H - C.edgePadding - h);
    const rect = {x,y,w,h};
    let ok=true;
    for(const o of obstacles){
      if(!(x+w+C.padding<o.x || x>o.x+o.w+C.padding || y+h+C.padding<o.y || y>o.y+o.h+C.padding)) {ok=false; break;}
    }
    if(ok) obstacles.push(rect);
  }
}

// ========================================
// COLLISION HELPERS (Solid obstacles)
// ========================================
function resolveCircleObstacles(entity){
  const obs = (inInterior && currentInterior && currentInterior.interior)? currentInterior.interior.obstacles : obstacles;
  
  // Check regular obstacles
  for(const o of obs){
    const cx = clamp(entity.x, o.x, o.x+o.w);
    const cy = clamp(entity.y, o.y, o.y+o.h);
    let dx = entity.x - cx;
    let dy = entity.y - cy;
    let dist2 = dx*dx + dy*dy;
    const r = entity.r||0;
    if(dist2 < r*r){
      if(dist2 === 0){
        const left = Math.abs(entity.x - o.x);
        const right = Math.abs((o.x+o.w) - entity.x);
        const top = Math.abs(entity.y - o.y);
        const bottom = Math.abs((o.y+o.h) - entity.y);
        const minEdge = Math.min(left,right,top,bottom);
        if(minEdge === left){ entity.x = o.x - r; }
        else if(minEdge === right){ entity.x = o.x+o.w + r; }
        else if(minEdge === top){ entity.y = o.y - r; }
        else { entity.y = o.y+o.h + r; }
      } else {
        const dist = Math.sqrt(dist2);
        const nx = dx/dist, ny = dy/dist;
        const overlap = r - dist;
        entity.x += nx * overlap;
        entity.y += ny * overlap;
      }
    }
  }
  
  // Check rivers using biome system (only in Stage 2 overworld)
  if(game.stage === 2 && !inInterior) {
    if(!canPassThrough(entity.x, entity.y, entity.r)) {
      // Entity is in a river without a bridge - push them out
      const riverBiomes = getBiomesByType('river');
      for(const river of riverBiomes) {
        const r = entity.r || 0;
        if(entity.x + r > river.x && entity.x - r < river.x + river.w && 
           entity.y + r > river.y && entity.y - r < river.y + river.h) {
          
          const cx = clamp(entity.x, river.x, river.x + river.w);
          const cy = clamp(entity.y, river.y, river.y + river.h);
          let dx = entity.x - cx;
          let dy = entity.y - cy;
          let dist2 = dx*dx + dy*dy;
          
          if(dist2 < r*r){
            if(dist2 === 0){
              const left = Math.abs(entity.x - river.x);
              const right = Math.abs((river.x + river.w) - entity.x);
              const top = Math.abs(entity.y - river.y);
              const bottom = Math.abs((river.y + river.h) - entity.y);
              const minEdge = Math.min(left, right, top, bottom);
              if(minEdge === left){ entity.x = river.x - r; }
              else if(minEdge === right){ entity.x = river.x + river.w + r; }
              else if(minEdge === top){ entity.y = river.y - r; }
              else { entity.y = river.y + river.h + r; }
            } else {
              const dist = Math.sqrt(dist2);
              const nx = dx/dist, ny = dy/dist;
              const overlap = r - dist;
              entity.x += nx * overlap;
              entity.y += ny * overlap;
            }
          }
        }
      }
    }
  }
}

function bulletHitsObstacle(b){
  const obs = (inInterior && currentInterior && currentInterior.interior)? currentInterior.interior.obstacles : obstacles;
  for(const o of obs){
    if(b.x > o.x-2 && b.x < o.x+o.w+2 && b.y > o.y-2 && b.y < o.y+o.h+2){
      return true;
    }
  }
  return false;
}

// Robust path check from previous to current position (prevents bullets sliding along edges)
function pathHitObstacle(lx,ly,x,y, r=2){
  const dx=x-lx, dy=y-ly; const dist=Math.hypot(dx,dy);
  const stepLen=Math.max(0.5, (r||2)*0.5);
  const steps=Math.max(8, Math.ceil(dist/stepLen));
  const obs = (inInterior && currentInterior && currentInterior.interior)? currentInterior.interior.obstacles : obstacles;
  for(let i=1;i<=steps;i++){
    const t=i/steps; const px=lerp(lx,x,t), py=lerp(ly,y,t);
    for(const o of obs){
      if(px > o.x-r && px < o.x+o.w+r && py > o.y-r && py < o.y+o.h+r){
        return {x:px, y:py};
      }
    }
  }
  return null;
}

function pointInObstacle(x,y,r=2){
  const obs = (inInterior && currentInterior && currentInterior.interior)? currentInterior.interior.obstacles : obstacles;
  for(const o of obs){ if(x>o.x-r && x<o.x+o.w+r && y>o.y-r && y<o.y+o.h+r) return true; }
  return false;
}

// ========================================
// WEAPON STATS & BALANCE - TUNE THESE VALUES
// ========================================
// TUNE: All weapon damage, fire rates, speeds, and properties
const WEP = TUNE.weapons;

function newWeapon(key){const d=JSON.parse(JSON.stringify(WEP[key])); d.key=key; d.ammo=d.mag||0; d.cool=0; 
  // Apply legacy specializations
  if(legacy.totals){
    if(d.type==='gun'){
      if(key==='pistol' && legacy.totals.specPistol){ d.dmg=Math.round(d.dmg*1.35); d.rpm=Math.round(d.rpm*1.25); d.mag=Math.round(d.mag*1.5); }
      if(key==='smg' && legacy.totals.specSmg){ d.dmg=Math.round(d.dmg*1.25); d.rpm=Math.round(d.rpm*1.35); d.mag=Math.round(d.mag*1.4); }
      if(key==='shotgun' && legacy.totals.specShotgun){ d.dmg=Math.round(d.dmg*1.4); d.pellets=(d.pellets||6)+1; d.mag=Math.round(d.mag*1.3); }
      if(key==='rifle' && legacy.totals.specRifle){ d.dmg=Math.round(d.dmg*1.3); d.rpm=Math.round(d.rpm*1.2); d.mag=Math.round(d.mag*1.4); }
      if(key==='sniper' && legacy.totals.specSniper){ d.dmg=Math.round(d.dmg*1.5); d.rpm=Math.round(d.rpm*1.2); d.mag=(d.mag||1)+2; }
    } else if(d.type==='melee' && legacy.totals.meleeMaster){ d.dmg=Math.round(d.dmg*1.8); d.range=Math.round(d.range*1.4); }
  }
  return d; }

// Damage & Legacy multipliers
function dmgMod(){
  let base = 1 + (legacy.totals.dmg||0)*0.02;
  if(playerGang && playerGang.perks.damageMultiplier) base *= playerGang.perks.damageMultiplier;
  if(player.equipBonuses && player.equipBonuses.damageBonus) base *= player.equipBonuses.damageBonus;
  return base;
}
function moveMod(){
  let base = 1 + (legacy.totals.move||0)*0.02;
  if(playerGang && playerGang.perks.speedBonus) base *= playerGang.perks.speedBonus;
  if(player.equipBonuses && player.equipBonuses.speedBonus) base *= player.equipBonuses.speedBonus;
  return base;
}
function reloadMod(){
  let base = 1 + (legacy.totals.reload||0)*0.03;
  if(playerGang && playerGang.perks.reloadSpeed) base *= playerGang.perks.reloadSpeed;
  if(player.equipBonuses && player.equipBonuses.reloadBonus) base *= player.equipBonuses.reloadBonus;
  return base;
}
function lifestealPct(){return (legacy.totals.lifesteal||0)*0.005;}
function maxHpBonus(){return (legacy.totals.hp||0)*5;}

// AI helper: LOS test
function lineIntersectsRect(x1,y1,x2,y2, r){ // Cohen–Sutherland-ish quick reject then segment-rect
  if(x1>=r.x && x1<=r.x+r.w && y1>=r.y && y1<=r.y+r.h) return true;
  const lines=[ [r.x,r.y,r.x+r.w,r.y], [r.x+r.w,r.y,r.x+r.w,r.y+r.h], [r.x+r.w,r.y+r.h,r.x,r.y+r.h], [r.x,r.y+r.h,r.x,r.y] ];
  for(const L of lines){ if(segmentsIntersect(x1,y1,x2,y2, ...L)) return true; }
  return false;
}
function segmentsIntersect(x1,y1,x2,y2,x3,y3,x4,y4){
  function ccw(ax,ay,bx,by,cx,cy){return (cy-ay)*(bx-ax)>(by-ay)*(cx-ax);} 
  return (ccw(x1,y1,x3,y3,x4,y4)!==ccw(x2,y2,x3,y3,x4,y4)) && (ccw(x1,y1,x2,y2,x3,y3)!==ccw(x1,y1,x2,y2,x4,y4));
}
function hasLOS(ax,ay,bx,by){
  const obs = (inInterior && currentInterior && currentInterior.interior)? currentInterior.interior.obstacles : obstacles;
  for(const o of obs){ if(lineIntersectsRect(ax,ay,bx,by,o)) return false; } return true;
}

// --------------------------------
// Simple corner navigation around first blocking obstacle
// --------------------------------
function firstBlockingObstacle(ax,ay,bx,by){
  const obs = (inInterior && currentInterior && currentInterior.interior)? currentInterior.interior.obstacles : obstacles;
  for(const o of obs){ if(lineIntersectsRect(ax,ay,bx,by,o)) return o; }
  return null;
}
function navAround(e, tx, ty){
  const o = firstBlockingObstacle(e.x,e.y,tx,ty); if(!o) return null;
  const pad = (e.r||8)+4;
  const cands=[
    {x:o.x-pad, y:o.y-pad},
    {x:o.x+o.w+pad, y:o.y-pad},
    {x:o.x-pad, y:o.y+o.h+pad},
    {x:o.x+o.w+pad, y:o.y+o.h+pad}
  ];
  let best=null, bestD=1e9;
  for(const c of cands){
    const cx=clamp(c.x, pad, G.W-pad), cy=clamp(c.y, pad, G.H-pad);
    // prefer corners we can reach directly
    if(!hasLOS(e.x,e.y,cx,cy)) continue;
    const d=Math.hypot(tx-cx,ty-cy);
    if(d<bestD){bestD=d; best={x:cx,y:cy};}
  }
  return best;
}

// ========================================
// ENEMY STATS & SPAWNING - TUNE THESE VALUES
// ========================================
// TUNE: All enemy health, speed, damage, and spawning properties
function spawnEnemy(type){
  const e=getFrom(enemyPool,()=>({alive:true,type:'grunt',x:0,y:0,r:8,hp:20,maxhp:20,speed:60, state:'seek', t:0, wep:null, cd:0, aim:0, reload:0, elite:false, coins:1}));
  e.type=type; e.alive=true; e.t=0; e.cd=0; e.reload=0; e.state='seek'; e.elite=false; e.coins=TUNE.enemies.coinsPerKill; 
  if(e.burnT==null){ e.burnT=0; e.iceT=0; e.shockT=0; e._burnAcc=0; }
  
  // TUNE: Enemy base speeds by type
  e.speed = (type==='swarmer'?TUNE.enemies.baseSpeed.swarmer:(type==='tank'?TUNE.enemies.baseSpeed.tank:TUNE.enemies.baseSpeed.grunt)); 
  e.r=(type==='tank'?TUNE.enemies.radius.tank:TUNE.enemies.radius.default);
  
  // sprite anim state
  e.animDir='idle'; e.animOn=false; e.animT=0; e.animPhase=false;
  // gun burst state
  e.burstLeft=0; e.burstPause=0;
  
  // TUNE: Enemy health pools by type
  if(type==='grunt'||type==='swarmer'||type==='tank'){ 
    e.wep=newWeapon(type==='tank'?'shotgun':'shortsword'); 
    e.hp=e.maxhp = (type==='tank'?TUNE.enemies.hp.tank: (type==='swarmer'?TUNE.enemies.hp.swarmer:TUNE.enemies.hp.grunt) ); 
  }
  else if(type==='shooter'){ 
    e.wep=newWeapon('pistol'); 
    e.hp=e.maxhp=TUNE.enemies.hp.shooter;  // TUNE: Shooter enemy HP
  }
  else if(type==='rifler'){ 
    e.wep=newWeapon('rifle'); 
    e.hp=e.maxhp=TUNE.enemies.hp.rifler;  // TUNE: Rifle enemy HP
  }
  else if(type==='smger'){ 
    e.wep=newWeapon('smg'); 
    e.hp=e.maxhp=TUNE.enemies.hp.smger;  // TUNE: SMG enemy HP
  }
  else if(type==='caster'){ 
    e.wep=null; 
    e.hp=e.maxhp=TUNE.enemies.hp.caster;  // TUNE: Caster enemy HP
  }
  
  // position at random edge
  const side=R.pick(['top','bottom','left','right']);
  if(side==='top'){ e.x=R.rint(20,WORLD.W-20); e.y=-15; }
  if(side==='bottom'){ e.x=R.rint(20,WORLD.W-20); e.y=WORLD.H+15; }
  if(side==='left'){ e.x=-15; e.y=R.rint(20,WORLD.H-20); }
  if(side==='right'){ e.x=WORLD.W+15; e.y=R.rint(20,WORLD.H-20); }
  enemies.push(e);
}

function spawnBoss(){
  const b=getFrom(enemyPool,()=>({alive:true,type:'boss',x:0,y:0,r:TUNE.boss.radius,hp:TUNE.boss.hp,maxhp:TUNE.boss.hp,speed:TUNE.boss.speed, state:'boss', t:0, cd:0, cdSmall:0, cdBig:1.0, rocketCD:1.0, powerUp:5.0, bossName:'', aim:0, coins:TUNE.boss.coins}));
  b.type='boss'; b.alive=true; b.hp=b.maxhp=TUNE.boss.hp; b.r=TUNE.boss.radius; b.speed=TUNE.boss.speed; b.state='boss'; b.t=0; b.cd=0; b.cdSmall=0; b.cdBig=1.0; b.rocketCD=1.0; b.powerUp=5.0; b.x=WORLD.W/2; b.y=WORLD.H*0.25;
  // Name by wave and switch to boss BGM
  if(game.wave===10){ b.bossName='Franklin'; switchToBossMusic('Franklin'); }
  else if(game.wave===20){ b.bossName='Trevor'; switchToBossMusic('Trevor'); }
  else { b.bossName='Boss'; switchToBossMusic('Franklin'); }
  enemies.push(b);
}

// ========================================
// WAVE PLANNING & DIFFICULTY - TUNE THESE VALUES
// ========================================
// TUNE: Wave composition, enemy counts, and progression
function planWave(w){
  const list=[]; const add=(t,n)=>{for(let i=0;i<n;i++) list.push(t)};
  
  if(w===1){ add('grunt', TUNE.waves.early.w1.grunt); }
  else if(w===2){ add('grunt', TUNE.waves.early.w2.grunt); }
  else if(w===3){ add('grunt', TUNE.waves.early.w3.grunt); add('swarmer', TUNE.waves.early.w3.swarmer); }
  
  else if(w<=7){ 
    add('grunt', TUNE.waves.mid.baseGrunt);
    add('swarmer', Math.max(0, w - TUNE.waves.mid.swarmerAfterWave));
    add('shooter', Math.max(1, w - TUNE.waves.mid.shooterAfterWave));
  }
  
  else if(w<=12){ 
    add('grunt', TUNE.waves.late.grunt);
    add('swarmer', TUNE.waves.late.swarmer);
    add('smger', TUNE.waves.late.smgerBase + Math.floor((w-8)/TUNE.waves.late.scaleEvery));
    add('rifler', TUNE.waves.late.riflerBase + Math.floor((w-8)/TUNE.waves.late.scaleEvery));
    add('tank', Math.floor((w - TUNE.waves.late.tankAfterWave) / TUNE.waves.late.scaleEvery));
  }
  
  else if(w<=30){ 
    add('swarmer', TUNE.waves.endgame.swarmer);
    add('smger', TUNE.waves.endgame.smger);
    add('rifler', TUNE.waves.endgame.rifler);
    add('tank', TUNE.waves.endgame.tank);
    add('caster', Math.floor((w-12)/TUNE.waves.endgame.casterEvery)+1);
  } else { 
    // Stage 2: continue endgame-like density
    add('swarmer', TUNE.waves.endgame.swarmer+2);
    add('smger', TUNE.waves.endgame.smger+2);
    add('rifler', TUNE.waves.endgame.rifler+1);
    add('tank', TUNE.waves.endgame.tank);
    add('caster', Math.floor((w-12)/TUNE.waves.endgame.casterEvery)+2);
  }
  return list;
}

// ========================================
// SHOP & ECONOMY - TUNE THESE VALUES
// ========================================
// TUNE: Shop item prices, effects, and availability
const shopPool=[
  // TUNE: Weapon prices and availability
  ()=>({kind:'weapon', key:'smg', name:'SMG', price:TUNE.economy.prices.smg, desc:'Fast projectile weapon.'}),      // TUNE: SMG price
  ()=>({kind:'weapon', key:'shotgun', name:'Shotgun', price:TUNE.economy.prices.shotgun, desc:'Pellet spread, close-range.'}), // TUNE: Shotgun price
  ()=>({kind:'weapon', key:'rifle', name:'Rifle', price:TUNE.economy.prices.rifle, desc:'Reliable, accurate.'}),       // TUNE: Rifle price
  ()=>({kind:'weapon', key:'rpg', name:'RPG', price:65, desc:'Massive explosive rocket.'}),
  
  // TUNE: Passive upgrade prices and effects
  ()=>({kind:'passive', key:'armor', name:'+1 Armor', price:TUNE.economy.prices.armor, desc:'Reduce incoming damage.', apply:()=>player.armor+=1}), // TUNE: Armor price
  
  // TUNE: Consumable prices and effects
  ()=>({kind:'consum', key:'heal', name:'Medkit', price:TUNE.economy.prices.medkit, desc:`Restore ${TUNE.economy.medkitHeal} HP now.`, apply:()=>player.hp=Math.min(player.hpMax, player.hp+TUNE.economy.medkitHeal)}), // TUNE: Medkit price and heal amount
  
  // TUNE: Luck upgrade price and effect
  ()=>({kind:'passive', key:'luck', name:'+2% Luck', price:TUNE.economy.prices.luck, desc:'Better drops.', apply:()=>{legacy.totals.luck=Math.min(10,(legacy.totals.luck||0)+1); saveLegacy(); renderLegacyPill();}}), // TUNE: Luck price and cap
];

// ========================================
// LEGACY BUFF SYSTEM - TUNE THESE VALUES
// ========================================
// TUNE: Legacy buff effects, steps, and caps for meta-progression
const LEGACY = TUNE.legacy;

function saveLegacy(){localStorage.setItem(LS_KEYS.LEGACY, JSON.stringify(legacy));}

// --------------------------------
// Projectiles / Bullets
// --------------------------------
function fireProjectile(x,y, angle, speed, dmg, friendly=true, life=1.5, spread=0, pierce=0, kind='bullet'){ life*= (TUNE.bullets.travelLifeMul||1);
  const b=getFrom(bulletPool,()=>({alive:true,x:0,y:0,vx:0,vy:0,r:3,life:0,dmg:0, friendly:true, pierce:0, from:'gun', lx:0, ly:0, color:null}));
  // Cap enemy/boss bullet counts to prevent lag (boss gets a higher cap)
  if(!friendly){ let activeEnemy=0, activeBoss=0; for(const bb of bullets){ if(bb.alive && !bb.friendly){ activeEnemy++; if(bb.fromBoss) activeBoss++; } }
    const bossActive=enemies.some(e=>e.alive && e.type==='boss');
    const cap = bossActive? TUNE.bullets.maxBossActive : TUNE.bullets.maxEnemyActive;
    if(activeEnemy>=cap){ return; }
  }
  const a = angle + (spread? ( (R.rand()*2-1)*spread*Math.PI/180 ):0);
  b.x=x; b.y=y; b.vx=Math.cos(a)*speed; b.vy=Math.sin(a)*speed; b.life=life; b.dmg=dmg; b.friendly=friendly; b.pierce=pierce; b.from=kind; b.r = (kind==='rpg'? (WEP.rpg.projRadius||12) : 3); b.stuck=0; 
  if(friendly){ if(legacy.totals.elemFire){ b.color='#ff5a4a'; } else if(legacy.totals.elemIce){ b.color='#57a4ff'; } else if(legacy.totals.elemElectric){ b.color='#ffd54a'; } else { b.color='#c7cbd1'; } } else { b.color='#c7cbd1'; }
  bullets.push(b);
  if(settings.sfx>0) AudioSys.beep('shoot');
}

function fireShotgun(x,y, angle, pellets, spreadDeg, speed, dmg, friendly){
  for(let i=0;i<pellets;i++) fireProjectile(x,y, angle + ((i-(pellets-1)/2)*(spreadDeg*Math.PI/180)/pellets), speed*(.9+R.rand()*.2), dmg, friendly, 0.9, spreadDeg*0.2);
}

// RPG explosion helper
function handleExplosion(x,y,dmg){
  const RADIUS = (WEP.rpg && WEP.rpg.aoe) ? WEP.rpg.aoe : 100;
  for(const e of enemies){ if(!e.alive) continue; const dx=e.x-x, dy=e.y-y; const d=Math.hypot(dx,dy); if(d<=RADIUS){ const fall=1-d/Math.max(1,RADIUS); damageEnemy(e, Math.round(dmg*fall)); const kb=fall*80; if(d>0){ e.x += (dx/d)*kb; e.y += (dy/d)*kb; } } }
  particles.push({alive:true,x:x,y:y,vx:0,vy:0,life:0.4,type:'explosion'});
}

// Hitscan for player sniper
function fireHitscan(x,y, angle, dmg){
  // Ray until wall bounds
  const maxLen=900; const endX=x+Math.cos(angle)*maxLen, endY=y+Math.sin(angle)*maxLen;
  // collide with enemies first
  let hit=null, hitDist=1e9;
  for(const e of enemies){ if(!e.alive) continue; const dx=e.x-x, dy=e.y-y; const proj=(dx*Math.cos(angle)+dy*Math.sin(angle)); if(proj<0) continue; const closestX=x+Math.cos(angle)*proj, closestY=y+Math.sin(angle)*proj; const d2=(e.x-closestX)**2+(e.y-closestY)**2; if(d2<= (e.r+2)**2){ const dist=Math.hypot(e.x-x,e.y-y); if(dist<hitDist){hit=e; hitDist=dist;} } }
  if(hit){
    // stop at first obstacle between player and target
    let blocked=false;
    for(const o of obstacles){ if(lineIntersectsRect(x,y,hit.x,hit.y,o)){ blocked=true; break; } }
    if(!blocked){ damageEnemy(hit, dmg); spawnHitFX(hit.x,hit.y); }
  }
  particles.push({alive:true,x:x,y:y,vx:0,vy:0,life:.05,type:'flash'});
  if(settings.sfx>0) AudioSys.beep('shoot');
}

// --------------------------------
// Damage & FX
// --------------------------------
// ========================================
// DAMAGE & COMBAT SYSTEM - TUNE THESE VALUES
// ========================================
function spawnHitFX(x,y){ 
  particles.push({alive:true,x,y,vx:0,vy:0,life:TUNE.fx.hitLife,type:'hit'}); // TUNE: Hit effect lifetime
  if(settings.sfx>0) AudioSys.beep('hit'); 
  if(settings.shake && !settings.reduceMotion) shake(TUNE.fx.shakeHit); // TUNE: Hit effect shake intensity
}

function damageEnemy(e, dmg){
  if(!e.alive) return; 
  
  // TUNE: Enemy damage calculation (armor reduction)
  let final=Math.max(1, Math.floor(dmg - (e.armor||0))); 
  e.hp-=final; 
  
  // TUNE: Score per damage point
  game.score+=Math.floor(final/TUNE.scoring.damageDivisor); 
  
  if(settings.dmgNums) floatText(`${final}`, e.x, e.y, '#fff');
  
  if(e.hp<=0){ 
    e.alive=false; 
    game.coins += e.coins; 
    
    // Lucky Wheel legacy strongly affects drop rates and coin amounts
    const lw = (legacy.totals.luckyWheel||0);
    const baseChance = TUNE.drops.coinDropBase + (legacy.totals.luck||0)*TUNE.drops.coinDropPerLuck;
    const boostedChance = clamp(baseChance * (1 + 0.5*lw), 0, 0.95);
    if(R.chance(boostedChance)){
      drops.push({alive:true,x:e.x,y:e.y,kind:'coin',life:TUNE.drops.coinLifetime, coinsExtra: lw});
    }
    // Vehicle wreck drop: base 10%, boosted by Lucky Wheel
    const wreckChance = 0.10 * (1 + 0.75*lw);
    if(e.type==='swarmer' && R.chance(wreckChance)){
      drops.push({alive:true,x:e.x,y:e.y,kind:'veh_wreck',life:TUNE.vehicle.dropLife});
    }
  } 
}

function damagePlayer(d){
  // TUNE: Player damage calculation (armor reduction)
  let dmg = Math.max(0, d - player.armor - (legacy.totals.armor||0));
  if(dmg<=0) dmg=0; 
  if(player.inVehicle){ player.vehicleHp = Math.max(0, player.vehicleHp - dmg); if(player.vehicleHp<=0){ player.inVehicle=false; player.superCar=false; player.r=TUNE.player.radius; } }
  else { player.hp -= dmg; } 
  
  if(settings.dmgNums) floatText(`-${dmg}`, player.x, player.y-12, '#ff7777'); 
  
  if(dmg>0){
    AudioSys.beep('hurt'); 
    if(settings.shake && !settings.reduceMotion) shake(TUNE.fx.shakeHurt); // TUNE: Screen shake intensity
  } 
  
  if(player.hp<=0) onPlayerDeath(); 
}

// ========================================
// VISUAL EFFECTS & FEEDBACK - TUNE THESE VALUES
// ========================================
// Damage numbers floating
const floats=[]; 
function floatText(t,x,y, color){
  floats.push({t, x, y, vy:TUNE.fx.floatVy, life:TUNE.fx.floatLife, color}); // TUNE: Damage number velocity and lifetime
}

// Screen shake
let shakeT=0, shakeMag=0; 
function shake(m){
  shakeT=TUNE.fx.shakeDuration; // TUNE: Shake duration
  shakeMag=Math.max(shakeMag,m); // TUNE: Maximum shake magnitude
} 

// --------------------------------
// Game Flow
// --------------------------------
let waveEnemies=[], spawnTimer=0, intermissionT=0; let shopItems=[];

function startRun(difficulty){
  game={state:STATE.RUN, difficulty, wave:1, score:0, coins:0, time:0, intermission:false, dead:false, stage:1};
  switchToNormalMusic();
  // reset RNG but keep stored seed
  const s=localStorage.getItem(LS_KEYS.SEED); R.reseed(hashStr(s)); // Note: obstacles use background tiles now; no random obstacle seeding
  // player reset
  player.x=G.W/2; player.y=G.H/2; player.vx=player.vy=0; player.weaponIndex=0; player.weapons=[newWeapon('pistol'), newWeapon('shortsword')]; if(legacy.totals.grapplingHook){ player.weapons.push(newWeapon('grapple')); } player.secondary=null; player.r=TUNE.player.radius; player.speed=TUNE.player.baseSpeed * (legacy.totals.meleeMaster?1.2:1); player.hpMax=TUNE.player.startHp+maxHpBonus(); player.hp=player.hpMax; player.armor=(TUNE.player.startArmor)+(legacy.totals.armor||0); player.stamina=player.staminaMax=TUNE.player.staminaMax; player.ammoReserve=TUNE.player.ammoReserve; player.dashMax = Math.max(0.5, TUNE.player.dashCooldown * (legacy.totals.doubleDash?0.75:1)); player.dashChargesMax = (legacy.totals.doubleDash?2:1); player.dashCharges = player.dashChargesMax; player.iframes=0;
  // Vehicle tracking
  player.inVehicle = false; player.vehicleType = null; player.vehicleDirection = 'idle'; player.lastMovement = {x: 0, y: 0};
  updateWeaponDisplay();
  // clear arrays
  bullets.length=0; enemies.length=0; particles.length=0; drops.length=0; floats.length=0;
  setWorldSize(G.W, G.H); camera.x=0; camera.y=0; camera.zoom=TUNE.camera.stage1Zoom||1; camera.targetZoom=TUNE.camera.stage1Zoom||1; camera.follow=false; camera.lock=false;
  genObstacles();
  setTxt('waveText', game.wave); setTxt('scoreText', game.score); setTxt('coinsText', game.coins); setTxt('seedText', R.seed);
  AudioSys.ensure();
  show('menu', false); show('pause', false); show('shop', false); show('gameover', false); show('how', false);
  const objHUD=$('#objectivesHUD'); if(objHUD) objHUD.style.display='none';
  nextWave();
}

function nextWave(){ waveEnemies = planWave(game.wave); spawnTimer=0; intermissionT=0; game.intermission=false;
  // Boss wave
  if(game.wave % TUNE.boss.interval===0){
    // clear normal spawns and spawn boss once
    waveEnemies.length=0;
    spawnBoss();
  }
  // Stage 2 trigger after wave 30 (when transitioning to 31)
  if(game.wave>30 && game.stage===1){ enterStage2(); }
}

// ========================================
// WAVE TRANSITIONS & SHOP - TUNE THESE VALUES
// ========================================
function endWave(){ 
  game.intermission=true; 
  intermissionT=TUNE.economy.intermissionSeconds; 
  buildShop(); 
  show('shop', true); 
  updateShopCoins();
}

// ========================================
// SHOP GENERATION - TUNE THESE VALUES
// ========================================
function buildShop(){ 
  shopItems=[]; 
  const n=TUNE.economy.shopItemsPerWave; // TUNE: Number of shop items offered per wave
  
  for(let i=0;i<n;i++){ 
    shopItems.push( shopPool[ R.rint(0, shopPool.length-1) ]() ); 
  }
  
  const grid=$('#shopGrid'); 
  grid.innerHTML=''; 
  shopItems.forEach((it,idx)=>{
    const el=document.createElement('div'); 
    el.className='perk'; 
    el.innerHTML=`<h3>${it.name}</h3><div class="muted small">${it.desc}</div><div class="price">${it.price}c</div><button class="btn" data-i="${idx}">Buy</button>`;
    grid.appendChild(el);
  });
  grid.querySelectorAll('button').forEach(btn=>btn.onclick=()=>buyShop(+btn.dataset.i));
}

function buyShop(i){ const it=shopItems[i]; if(!it) return; if(game.coins<it.price){return;} game.coins-=it.price; updateShopCoins(); AudioSys.beep('buy');
  if(it.kind==='weapon'){ const w=newWeapon(it.key); // simple: set as primary
    if(player.weapons.length<3) player.weapons.push(w); else player.weapons[0]=w; 
    updateWeaponDisplay();
  }
  else if(it.apply) it.apply();
}
function updateShopCoins(){ setTxt('shopCoins', game.coins); setTxt('coinsText', game.coins); }
$('#continueBtn').onclick=()=>{show('shop', false); // prepare next wave
  game.wave++; setTxt('waveText', game.wave); 
  if(game.stage===1 && game.wave>30){ enterStage2(); } else { nextWave(); }
};

function onPlayerDeath(){ if(game.dead) return; game.dead=true; AudioSys.beep('death');
  // best score
  if(game.score>best){best=game.score; localStorage.setItem(LS_KEYS.BEST, best); setTxt('bestText', best);} 
  // Present legacy choices panel
  show('gameover', true); setTxt('goScore', game.score); setTxt('goWave', game.wave);
  legacyChoicesUI(true);
}

let legacySel=null, legacyRerolled=false;
function legacyChoicesUI(initial){ const cont=$('#legacyChoices'); cont.innerHTML=''; const keys=Object.keys(LEGACY);
  const picks=[]; while(picks.length<3){ const k=R.pick(keys); if(!picks.includes(k)) picks.push(k); }
  cont.dataset.keys=picks.join(','); legacySel=null; $('#takeLegacy').disabled=true; 
  // Inline SVG icons for each legacy key (no external files needed)
  const LEGACY_ICONS = {
    doubleDash: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="64" height="64" rx="10" fill="%230f1726"/><path d="M12 24 L30 24 L24 18 L36 32 L24 46 L30 40 L12 40 Z" fill="%23ffd45a"/><path d="M34 24 L52 24 L46 18 L58 32 L46 46 L52 40 L34 40 Z" fill="%23ffe27a"/></svg>',
    carMaster: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="64" height="64" rx="10" fill="%230f1726"/><rect x="10" y="26" width="44" height="14" rx="4" fill="%2361dafb"/><circle cx="20" cy="44" r="5" fill="%23e7eef7"/><circle cx="44" cy="44" r="5" fill="%23e7eef7"/></svg>',
    specPistol: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="64" height="64" rx="10" fill="%230f1726"/><text x="32" y="38" font-size="28" text-anchor="middle" fill="%23e7eef7" font-family="system-ui,Arial">P</text></svg>',
    specSmg: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="64" height="64" rx="10" fill="%230f1726"/><text x="32" y="38" font-size="24" text-anchor="middle" fill="%23e7eef7" font-family="system-ui,Arial">SMG</text></svg>',
    specShotgun: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="64" height="64" rx="10" fill="%230f1726"/><text x="32" y="38" font-size="22" text-anchor="middle" fill="%23e7eef7" font-family="system-ui,Arial">SG</text></svg>',
    specRifle: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="64" height="64" rx="10" fill="%230f1726"/><text x="32" y="38" font-size="26" text-anchor="middle" fill="%23e7eef7" font-family="system-ui,Arial">R</text></svg>',
    specSniper: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="64" height="64" rx="10" fill="%230f1726"/><text x="32" y="38" font-size="26" text-anchor="middle" fill="%23e7eef7" font-family="system-ui,Arial">S</text></svg>',
    meleeMaster: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="64" height="64" rx="10" fill="%230f1726"/><path d="M16 46 L30 32 L36 38 L22 52 Z" fill="%23ffd166"/><rect x="34" y="20" width="6" height="14" fill="%23ffd166"/></svg>',
    elemFire: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="64" height="64" rx="10" fill="%230f1726"/><path d="M32 14 C22 26, 40 28, 30 40 C26 46, 34 52, 40 44 C46 36, 42 28, 32 14 Z" fill="%23ff6b6b"/></svg>',
    elemIce: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="64" height="64" rx="10" fill="%230f1726"/><path d="M32 14 L38 28 L54 32 L38 36 L32 50 L26 36 L10 32 L26 28 Z" fill="%2363d3ff"/></svg>',
    elemElectric: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="64" height="64" rx="10" fill="%230f1726"/><path d="M28 12 L44 28 L36 28 L50 44 L30 36 L36 36 Z" fill="%23ffd45a"/></svg>',
    grapplingHook: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="64" height="64" rx="10" fill="%230f1726"/><circle cx="34" cy="20" r="6" fill="%23e7eef7"/><path d="M34 26 L34 44 C34 50 26 52 22 46" stroke="%23e7eef7" stroke-width="4" fill="none"/></svg>',
    luckyWheel: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="64" height="64" rx="10" fill="%230f1726"/><circle cx="32" cy="32" r="16" fill="%23ffd166"/><circle cx="32" cy="32" r="8" fill="%230f1726"/></svg>'
  };
  picks.forEach(k=>{
    const info=LEGACY[k]; const cur=(legacy.totals[k]||0); const atCap=cur>=info.cap;
    const el=document.createElement('div'); el.className='perk'; const imgName = `sprites/legacy/legacy_${k}.png`; const src = LEGACY_ICONS[k]||imgName;
    const row=document.createElement('div'); row.style.display='flex'; row.style.gap='10px'; row.style.alignItems='center';
    const img=document.createElement('img'); img.alt=k; img.width=48; img.height=48; img.style.objectFit='contain'; img.style.border='1px solid var(--stroke)'; img.style.borderRadius='8px'; img.style.background='#0f1726'; img.src=src;
    const desc=document.createElement('div'); desc.innerHTML = `<h3>${info.name}</h3><div class="muted small">${info.desc}</div><div class="small">Owned: <b>${cur}</b> / ${info.cap}</div>`;
    row.appendChild(img); row.appendChild(desc); el.appendChild(row);
    const btn=document.createElement('button'); btn.className='btn'; btn.textContent= atCap? 'At Cap' : 'Select'; btn.disabled=atCap; btn.onclick=()=>{ legacySel=k; [...cont.querySelectorAll('.perk')].forEach(p=>p.style.outline=''); el.style.outline='2px solid var(--accent)'; $('#takeLegacy').disabled=false; };
    el.appendChild(btn); cont.appendChild(el);
  });
  $('#rerollLegacy').disabled = legacyRerolled; 
}
$('#rerollLegacy').onclick=()=>{ if(legacyRerolled) return; legacyRerolled=true; legacyChoicesUI(false); };
$('#takeLegacy').onclick=()=>{ if(!legacySel) return; const info=LEGACY[legacySel]; legacy.totals[legacySel]=Math.min(info.cap, (legacy.totals[legacySel]||0)+info.step); saveLegacy(); renderLegacyPill(); legacyRerolled=false; show('gameover', false); startRun(game.difficulty); };

// Pause
function togglePause(){ if(game.state!==STATE.RUN) return; game.state=STATE.PAUSE; show('pause', true); setTxt('pWave', game.wave); setTxt('pScore', game.score); const bgmEl=document.getElementById('bgm'); if(bgmEl){ bgmEl.pause(); } }
$('#resumeBtn').onclick=()=>{game.state=STATE.RUN; show('pause', false); const bgmEl=document.getElementById('bgm'); if(bgmEl){ bgmEl.play().catch(()=>{}); } } ;
$('#pauseSettingsBtn').onclick=()=>show('settings', true);
$('#quitBtn').onclick=()=>{ show('pause', false); show('menu', true); game.state=STATE.MENU; switchToMenuMusic(); };

// Menu buttons
$('#startBtn').onclick=()=>{show('menu', false); startRun(0);} ;
$('#hardBtn').onclick=()=>{show('menu', false); startRun(1);} ;
$('#howBtn').onclick=()=>show('how', true);
$('#howClose').onclick=()=>show('how', false);
$('#settingsBtn').onclick=()=>show('settings', true);

// -----------------------------
// Update & Render Loop
// -----------------------------
let last=performance.now(), acc=0, dt=1/60;
function loop(now){ const el=now-last; last=now; acc+=Math.min(0.25, el/1000);
  while(acc>=dt){ update(dt); acc-=dt; }
  render(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);

function update(dt){
  if(game.state!==STATE.RUN){ if(game.state===STATE.STAGE2){ if(stage2Transition.active){ if(stage2Transition.phase==='show'){ stage2Transition.t=Math.max(0, stage2Transition.t-dt); updateCamera(dt); if(stage2Transition.t<=0){ stage2Transition.phase='return'; 
        // set up a smooth zoom-in to quarter-world view and a 30s tour around edges
        const zx=G.W/Math.max(1,WORLD.W/2), zy=G.H/Math.max(1,WORLD.H/2); const quarterZoom=Math.min(zx,zy)*0.98; stage2Transition.qZoom = quarterZoom;
        camera.lerpSpeed = TUNE.camera.transitionZoom.tourSpeed || 2.0; // restore faster but smooth zoom for tour setup
        camera.targetZoom=quarterZoom; 
        centerWorldViewAtCurrentZoom();
        // Build tour waypoints (positions are world-space camera.x/y targets)
        const qz = stage2Transition.qZoom||quarterZoom; const viewW = G.W/qz, viewH = G.H/qz;
        const leftX = 0, rightX = Math.max(0, WORLD.W - viewW);
        const topY = 0, bottomY = Math.max(0, WORLD.H - viewH);
        const midX = Math.max(0, (WORLD.W - viewW)/2), midY = Math.max(0, (WORLD.H - viewH)/2);
        const seg = (d,x,y,z)=>({d,x,y,z});
        const totalTour=30.0; const per=totalTour/8; // eight segments including final return to middle
        stage2Transition.tourQueue=[
          seg(per, rightX, midY, qz),
          seg(per, rightX, bottomY, qz),
          seg(per, leftX, bottomY, qz),
          seg(per, leftX, topY, qz),
          seg(per, rightX, topY, qz),
          seg(per, rightX, bottomY, qz),
          seg(per, leftX, bottomY, qz),
          seg(per, midX, midY, qz)
        ];
        stage2Transition.curSeg=stage2Transition.tourQueue.shift(); stage2Transition.segT=stage2Transition.curSeg? stage2Transition.curSeg.d:0;
      } } else if(stage2Transition.phase==='return'){
        // Zoom towards target and pan along tour
        // Smooth zoom interpolation happens in updateCamera via camera.targetZoom
        if(stage2Transition.curSeg){
          stage2Transition.segT = Math.max(0, stage2Transition.segT - dt);
          // Lerp camera.x/y towards segment target
          const lerpAmt=clamp(dt*1.2,0,1);
          camera.x = camera.x + (stage2Transition.curSeg.x - camera.x)*lerpAmt;
          camera.y = camera.y + (stage2Transition.curSeg.y - camera.y)*lerpAmt;
          camera.targetZoom = stage2Transition.curSeg.z;
          updateCamera(dt);
          if(stage2Transition.segT<=0){ stage2Transition.curSeg = stage2Transition.tourQueue.shift(); if(stage2Transition.curSeg){ stage2Transition.segT=stage2Transition.curSeg.d; } else { // tour complete
              stage2Transition.active=false; game.state=STATE.RUN; camera.follow=true; camera.lock=false; 
              // Set gameplay zoom to tunable Stage 2 zoom level
              camera.targetZoom = TUNE.camera.stage2Zoom || 0.5; camera.lerpSpeed=2.5; centerWorldViewAtCurrentZoom();
              nextWave();
            } }
        } else {
          updateCamera(dt);
        }
      } } } return; } game.time+=dt; if(player.iframes>0) player.iframes-=dt;
  const bossActive = enemies.some(e=>e.alive && e.type==='boss');
    // ========================================
  // SPAWNING & WAVE MANAGEMENT - TUNE THESE VALUES
  // ========================================
  // spawn
  if(!game.intermission){ 
    const aliveNow=enemies.filter(e=>e.alive).length; 
    
    // TUNE: Maximum enemies alive at once (spawn cap)
    const spawnCap=(game.wave<=2?TUNE.spawn.capWave2:(game.wave<=4?TUNE.spawn.capWave4:Math.min(TUNE.spawn.capBase+Math.floor(game.wave/3)*TUNE.spawn.capPer3Waves,TUNE.spawn.capMax))); 
    
    if(aliveNow<spawnCap && waveEnemies.length>0){ 
      spawnTimer-=dt; 
      if(spawnTimer<=0){ 
        // Spawn a group around the player
        const groupSize = (game.wave<=3?TUNE.spawn.groupSizeEarly:TUNE.spawn.groupSizeLate);
        const arc = TUNE.spawn.groupArcSpreadDeg * Math.PI/180;
        const baseAng = R.rand()*Math.PI*2;
        for(let gi=0; gi<groupSize && waveEnemies.length>0; gi++){
          const t=waveEnemies.shift(); 
          // pick side opposite to player position to ensure distance
                     const preferLeft = player.x > WORLD.W*0.5; const preferTop = player.y > WORLD.H*0.5;
          const sides = [];
          sides.push(preferLeft? 'left':'right'); sides.push(preferTop? 'top':'bottom'); sides.push('left','right','top','bottom');
          let sx=player.x, sy=player.y;
          for(const sidePick of sides){
            let tx=player.x, ty=player.y; const margin=80;
            if(sidePick==='left'){ tx = R.rint(-20, Math.max(-20, 80)); ty=R.rint(margin, WORLD.H-margin); }
            if(sidePick==='right'){ tx = R.rint(Math.min(WORLD.W+20, WORLD.W-80), WORLD.W+20); ty=R.rint(margin, WORLD.H-margin); }
            if(sidePick==='top'){ ty = R.rint(-20, Math.max(-20, 80)); tx=R.rint(margin, WORLD.W-margin); }
            if(sidePick==='bottom'){ ty = R.rint(Math.min(WORLD.H+20, WORLD.H-80), WORLD.H+20); tx=R.rint(margin, WORLD.W-margin); }
            // ensure a minimum distance from player
            if(Math.hypot(tx-player.x, ty-player.y) >= Math.max(180, TUNE.spawn.groupRadius*0.9)) { sx=tx; sy=ty; break; }
          }
          const side = (sx<0?'left':(sx>WORLD.W?'right':(sy<0?'top':'bottom')));
          // temporarily place via side to reuse existing edge logic
          spawnEnemy(t);
          const e = enemies[enemies.length-1];
          e.x = sx; e.y = sy;
        }
        
        // TUNE: Spawn timer between enemy groups (seconds)
        spawnTimer=(game.wave<=3?TUNE.spawn.intervalEarly:TUNE.spawn.intervalLate);
      } 
    } 
    // If a boss just died, switch back to normal music
    const hadBoss = enemies.some(e=>e.type==='boss');
    const bossAlive = enemies.some(e=>e.alive && e.type==='boss');
    if(hadBoss && !bossAlive){ switchToNormalMusic(); }
    if(waveEnemies.length===0 && enemies.every(e=>!e.alive)) { endWave(); } 
  }

  // Player movement
  let vehicleSpeedMul = 1;
  if(player.inVehicle && player.vehicleType) {
    if(player.vehicleType === 'cop_car') vehicleSpeedMul = TUNE.vehicle.speedMul;
    else if(player.vehicleType === 'super_car') vehicleSpeedMul = TUNE.superCar.speedMul;
    else if(player.vehicleType === 'ferrari') vehicleSpeedMul = TUNE.ferrari.speedMul;
    else if(player.vehicleType === 'armored_van') vehicleSpeedMul = TUNE.armoredVan.speedMul;
    else vehicleSpeedMul = TUNE.vehicle.speedMul;
  } else if(player.inVehicle) {
    vehicleSpeedMul = TUNE.vehicle.speedMul; // Fallback
  }
  const baseSpeed=(player.inVehicle? (player.speed*vehicleSpeedMul) : player.speed)*moveMod()*(game.difficulty?TUNE.difficulty.playerSpeedMulHard:1);
  let ax=(keys['d']?1:0)-(keys['a']?1:0); let ay=(keys['s']?1:0)-(keys['w']?1:0); let m=Math.hypot(ax,ay)||1; player.vx= (ax/m)*baseSpeed; player.vy=(ay/m)*baseSpeed; 
  
  // Update vehicle direction if in vehicle
  if(player.inVehicle && player.vehicleType) {
    const movementThreshold = 5; // Minimum speed to change direction
    if(Math.abs(player.vx) > movementThreshold || Math.abs(player.vy) > movementThreshold) {
      // Determine primary movement direction
      if(Math.abs(player.vx) > Math.abs(player.vy)) {
        // Horizontal movement dominates
        player.vehicleDirection = player.vx > 0 ? 'right' : 'left';
      } else {
        // Vertical movement dominates  
        player.vehicleDirection = player.vy > 0 ? 'down' : 'up';
      }
    } else {
      // Not moving fast enough, use idle
      player.vehicleDirection = 'idle';
    }
  }
  
  player.x += player.vx*dt; player.y += player.vy*dt; resolveCircleObstacles(player); 
  // Don't clamp to world bounds if in interior - that's handled separately
  if(!inInterior){ player.x=clamp(player.x,10,WORLD.W-10); player.y=clamp(player.y,10,WORLD.H-10); }
  // Building door check (only in stage 2 overworld)
  if(game.stage===2 && !inInterior && !player.inVehicle){ for(const b of buildings){ const d=b.door; if(d && player.x>d.x && player.x<d.x+d.w && player.y>d.y && player.y<d.y+d.h){ enterBuilding(b); break; } } }
  else if(inInterior){ // allow exit via same door area positioned near player (simple rule: press F to exit)
    if(keys['f']){ exitBuilding(); keys['f']=false; }
  }
  // sprite anim state
  if(Math.abs(player.vx)>5){ player.animOn=true; player.animDir = (player.vx<0? 'left':'right'); player.animT+=dt; if(player.animT>(TUNE.sprites.player.step||0.12)){ player.animT=0; player.animPhase=!player.animPhase; } } else { player.animOn=false; player.animDir='idle'; player.animT=0; player.animPhase=false; }
  player.facing = Math.atan2(mouse.y-player.y, mouse.x-player.x);

  // ========================================
  // PLAYER ABILITIES & COMBAT - TUNE THESE VALUES
  // ========================================
  // Dash
  player.dashCD=Math.max(0, player.dashCD-dt); if(player.dashCD<=0 && player.dashCharges<player.dashChargesMax){ player.dashCharges=player.dashChargesMax; } 
  if(keys['shift'] && player.dashCD<=0 && player.dashCharges>0 && player.stamina>=TUNE.player.dashCost){
    player.dashCharges--; player.dashCD= (player.dashCharges>0? 0.12 : player.dashMax);
    player.stamina-=TUNE.player.dashCost;
    player.x+=Math.cos(player.facing)*TUNE.player.dashDistance;
    player.y+=Math.sin(player.facing)*TUNE.player.dashDistance;
    AudioSys.beep('dash');
    if(settings.shake && !settings.reduceMotion) shake(TUNE.fx.shakeHit);
  }
  
  // TUNE: Stamina regeneration rate (per second)
  player.stamina=clamp(player.stamina+TUNE.player.staminaRegenPerSec*dt,0,player.staminaMax);

  // Firing
  const wep=player.weapons[player.weaponIndex]; wep.cool=Math.max(0,wep.cool-dt); if(mouse.wheel){ player.weaponIndex=(player.weaponIndex + (mouse.wheel>0?1:-1)+player.weapons.length)%player.weapons.length; mouse.wheel=0; updateWeaponDisplay(); }
  if(keys['q']){ player.weaponIndex=(player.weaponIndex+1)%player.weapons.length; keys['q']=false; updateWeaponDisplay(); }
  if(wep.type==='gun'){
    if(player.reloading){ player.reloadTimer-=dt*(1+0.03*(legacy.totals.reload||0)); if(player.reloadTimer<=0){ player.reloading=false; wep.ammo=wep.mag; updateWeaponDisplay(); }
    } else if((mouse.down || keys[' ']) && wep.cool<=0){ if(wep.ammo<=0){ // reload
        player.reloading=true; player.reloadTimer=wep.reload/reloadMod(); 
      } else {
        const fireRateMod = playerGang?.perks?.fireRateBonus || 1;
        wep.cool=60/(wep.rpm * fireRateMod); 
        const ang=player.facing; // Declare ang at proper scope for muzzle flash
        
        // Special weapon: Double Pump Shotgun - fires twice before reload
        if(wep.key==='double_shotgun' && wep.doublePump){
          if(!wep.pumpCount) wep.pumpCount = 0;
          wep.pumpCount++;
          wep.ammo--;
          fireShotgun(player.x,player.y,ang, wep.pellets||10, wep.spread, wep.projSpeed, wep.dmg*dmgMod(), true); 
          playSfx('shotgun');
          // After second shot, force reload
          if(wep.pumpCount >= 2) {
            wep.pumpCount = 0;
            if(wep.ammo <= 0) {
              player.reloading=true; 
              player.reloadTimer=wep.reload/reloadMod();
            }
          }
        } else {
          wep.ammo--; 
          if(wep.hitscan){ fireHitscan(player.x,player.y,ang, wep.dmg*dmgMod()); playSfx('rifle'); }
          else if(wep.key==='shotgun'){ fireShotgun(player.x,player.y,ang, wep.pellets||6, wep.spread, wep.projSpeed, wep.dmg*dmgMod(), true); playSfx('shotgun'); }
          else if(wep.key==='rpg'){ fireProjectile(player.x,player.y,ang,wep.projSpeed, wep.dmg*dmgMod(), true, 2.0, 0, 0, 'rpg'); playSfx('rpg_fire'); }
          else if(wep.key==='grapple'){
            const b = fireProjectile(player.x,player.y,ang,wep.projSpeed, 0, true, 0.8, 0, 0, 'grapple');
            if(b){ b.ropePts=[{x:player.x,y:player.y}], b.maxRope=24; player.grappling=true; player.grappleBullet=b; }
          } else { fireProjectile(player.x,player.y,ang,wep.projSpeed, wep.dmg*dmgMod(), true, 1.5, wep.spread, 0); playSfx(wep.key); }
        }
        // Tiny muzzle flash and smoke puff at player muzzle
        { const mx = player.x + Math.cos(ang)* (player.r+6); const my = player.y + Math.sin(ang)* (player.r+6);
          particles.push({alive:true,x:mx,y:my,vx:0,vy:0,life:0.05,type:'muzzle'});
          particles.push({alive:true,x:mx,y:my-8,vx:(R.rand()*2-1)*8,vy:(R.rand()*2-1)*8,life:0.14,maxLife:0.14,type:'smokeTiny'});
          particles.push({alive:true,x:mx,y:my,a:ang,life:0.05,maxLife:0.05,type:'muzzleCone'});
        }
        updateWeaponDisplay();
      }
    }
  } else if(wep.type==='melee'){
    if((mouse.down || keys[' ']) && wep.cool<=0 && player.stamina>=wep.stamina){ wep.cool=wep.cooldown; player.stamina-=wep.stamina; meleeSwing(wep); }
  }
  if(keys['r'] && !player.reloading && wep.type==='gun' && wep.ammo<wep.mag){ player.reloading=true; player.reloadTimer=wep.reload/(1+0.03*(legacy.totals.reload||0)); }

  // Bullets update
  for(const b of bullets){
    if(!b.alive) continue;
    b.lx=b.x; b.ly=b.y;
    b.x+=b.vx*dt; b.y+=b.vy*dt;

    // Grapple rope: extend rope points while in flight
    if(b.from==='grapple' && b.friendly){
      if(!b.ropePts) b.ropePts=[{x:player.x,y:player.y}];
      const last=b.ropePts[b.ropePts.length-1];
      if(!last || Math.hypot((b.x-last.x),(b.y-last.y))>8){ b.ropePts.push({x:b.x,y:b.y}); if(b.ropePts.length> (b.maxRope||24)) b.ropePts.shift(); }
    }

    // RPG smoke trail
    if(b.from==='rpg'){
      for(let i=0;i<2;i++){
        const offA = R.rand()*Math.PI*2; const offR = 4+R.rand()*6; const L = 0.45+R.rand()*0.25;
        const tailA = (b.vx||b.vy)? Math.atan2(b.vy,b.vx) : 0;
        particles.push({alive:true,
          x:b.x-Math.cos(tailA)*8 + Math.cos(offA)*offR,
          y:b.y-Math.sin(tailA)*8 + Math.sin(offA)*offR,
          vx:(R.rand()*2-1)*10, vy:(R.rand()*2-1)*10, life:L, maxLife:L, type:'smoke'});
      }
    }

         // Obstacle collision (skip for enemy/boss during boss wave to let shots clear off-screen)
      const skipObs = (!b.friendly && bossActive);
      if(!skipObs){
        const rr=b.r||2; const ph = pathHitObstacle(b.lx,b.ly,b.x,b.y, rr);
        if(ph || pointInObstacle(b.x,b.y,rr)){
          const hit=ph||{x:b.x,y:b.y};
          if(b.from==='grapple' && b.friendly){ player.grappleX=hit.x; player.grappleY=hit.y; player.grappling=true; if(b.ropePts) player.grappleRopePts=b.ropePts.slice(); b.alive=false; continue; }
          if(!ph){ b.stuck = (b.stuck||0) + dt; if(b.stuck>0.05){ if(b.from==='rpg'){ handleExplosion(b.x,b.y,b.dmg); if(b.friendly) playSfx('rpg_explosion'); } else { particles.push({alive:true,x:b.x,y:b.y,vx:0,vy:0,life:TUNE.bullets.impactLinger,type:'hit'}); } b.alive=false; continue; } }
          else { b.x=hit.x; b.y=hit.y; if(b.from==='grapple' && b.friendly){ player.grappleX=b.x; player.grappleY=b.y; player.grappling=true; if(b.ropePts) player.grappleRopePts=b.ropePts.slice(); b.alive=false; continue; } if(b.from==='rpg'){ handleExplosion(b.x,b.y,b.dmg); if(b.friendly) playSfx('rpg_explosion'); } else { particles.push({alive:true,x:b.x,y:b.y,vx:0,vy:0,life:TUNE.bullets.impactLinger,type:'hit'}); } b.alive=false; continue; }
        }
      }

    // Lifetime / off-screen
    b.life-=dt;
    const off = (b.x<-20 || b.x>WORLD.W+20 || b.y<-20 || b.y>WORLD.H+20);
    if(b.friendly){ if(off){ b.alive=false; continue; } }
    else { if(off || b.life<=0){ b.alive=false; continue; } }
    // RPG: on natural expiry (only applies to enemy rockets) explode
    if(b.life<=0 && b.from==='rpg'){ handleExplosion(b.x,b.y,b.dmg); b.alive=false; continue; }

    if(b.friendly){
      for(const e of enemies){
        if(!e.alive) continue;
        const dx=e.x-b.x, dy=e.y-b.y;
        if(dx*dx+dy*dy < (e.r+(b.r||2))*(e.r+(b.r||2))){
          if(b.from==='rpg') handleExplosion(b.x,b.y,b.dmg);
          else {
            damageEnemy(e, Math.round(b.dmg));
            // elemental proc: 30% chance; exclusive (apply only if none active)
            const canApply = (e.burnT||0)<=0 && (e.iceT||0)<=0 && (e.shockT||0)<=0;
            if(canApply && Math.random() < (TUNE.status.procChance||0.3)){
              if(legacy.totals.elemFire){ e.burnT = Math.max(e.burnT||0, TUNE.status.burn.duration); }
              else if(legacy.totals.elemIce){ e.iceT = Math.max(e.iceT||0, TUNE.status.ice.duration); }
              else if(legacy.totals.elemElectric){ e.shockT = Math.max(e.shockT||0, TUNE.status.shock.duration); }
            }
            if(lifestealPct()>0){ player.hp = Math.min(player.hpMax, player.hp + b.dmg*lifestealPct()); }
          }
          b.alive=false; break;
        }
      }
      
      // Check quest enemy and boss collisions
      if(inInterior && currentInterior?.interior) {
        const interior = currentInterior.interior;
        
        // Quest enemies
        for(const e of interior.questEnemies) {
          if(!e.alive) continue;
          const dx = e.x - b.x, dy = e.y - b.y;
          if(dx*dx + dy*dy < (e.r + (b.r||2)) * (e.r + (b.r||2))) {
            if(b.from==='rpg') handleExplosion(b.x,b.y,b.dmg);
            else {
              damageEnemy(e, Math.round(b.dmg));
              // elemental proc: 30% chance; exclusive (apply only if none active)
              const canApply = (e.burnT||0)<=0 && (e.iceT||0)<=0 && (e.shockT||0)<=0;
              if(canApply && Math.random() < (TUNE.status.procChance||0.3)){
                if(legacy.totals.elemFire){ e.burnT = Math.max(e.burnT||0, TUNE.status.burn.duration); }
                else if(legacy.totals.elemIce){ e.iceT = Math.max(e.iceT||0, TUNE.status.ice.duration); }
                else if(legacy.totals.elemElectric){ e.shockT = Math.max(e.shockT||0, TUNE.status.shock.duration); }
              }
              if(lifestealPct()>0){ player.hp = Math.min(player.hpMax, player.hp + b.dmg*lifestealPct()); }
            }
            b.alive = false;
            break;
          }
        }
        
        // Quest boss
        const boss = interior.npc;
        if(boss && boss.type === 'quest_boss' && boss.alive) {
          const dx = boss.x - b.x, dy = boss.y - b.y;
          if(dx*dx + dy*dy < (boss.r + (b.r||2)) * (boss.r + (b.r||2))) {
            if(b.from==='rpg') handleExplosion(b.x,b.y,b.dmg);
            else {
              damageEnemy(boss, Math.round(b.dmg));
              // elemental proc: 30% chance; exclusive (apply only if none active)
              const canApply = (boss.burnT||0)<=0 && (boss.iceT||0)<=0 && (boss.shockT||0)<=0;
              if(canApply && Math.random() < (TUNE.status.procChance||0.3)){
                if(legacy.totals.elemFire){ boss.burnT = Math.max(boss.burnT||0, TUNE.status.burn.duration); }
                else if(legacy.totals.elemIce){ boss.iceT = Math.max(boss.iceT||0, TUNE.status.ice.duration); }
                else if(legacy.totals.elemElectric){ boss.shockT = Math.max(boss.shockT||0, TUNE.status.shock.duration); }
              }
              if(lifestealPct()>0){ player.hp = Math.min(player.hpMax, player.hp + b.dmg*lifestealPct()); }
            }
            b.alive = false;
          }
        }
      }
    } else {
      const dx=player.x-b.x, dy=player.y-b.y;
      if(dx*dx+dy*dy < (player.r+(b.r||2))*(player.r+(b.r||2))){
        damagePlayer(Math.round(b.dmg)); b.alive=false;
      }
    }
  }

  // ========================================
  // ENEMY AI & BEHAVIOR - TUNE THESE VALUES
  // ========================================
  // Enemies update & AI
  for(const e of enemies){ 
    if(!e.alive) continue; 
    e.t+=dt; 
    const dx=player.x-e.x, dy=player.y-e.y; 
    const dist=Math.hypot(dx,dy); 
    const ang=Math.atan2(dy,dx); 
    e.aim=ang;
    
    // status ticking and particles
    if(e.burnT>0){ e.burnT=Math.max(0,e.burnT-dt); e._burnAcc=(e._burnAcc||0)+dt; if(e._burnAcc>=1){ e._burnAcc=0; damageEnemy(e, TUNE.status.burn.dps); } if(Math.random()<0.15){ particles.push({alive:true,x:e.x+(Math.random()*6-3),y:e.y-e.r-6+(Math.random()*6),vx:0,vy:-8,life:0.2,type:'burnSpark'});} }
    if(e.iceT>0){ e.iceT=Math.max(0,e.iceT-dt); if(Math.random()<0.15){ particles.push({alive:true,x:e.x+(Math.random()*8-4),y:e.y-e.r-8+(Math.random()*8),vx:0,vy:-6,life:0.25,type:'iceSpark'});} }
    if(e.shockT>0){ e.shockT=Math.max(0,e.shockT-dt); if(Math.random()<0.2){ particles.push({alive:true,x:e.x+(Math.random()*10-5),y:e.y-e.r-10+(Math.random()*10),vx:0,vy:-12,life:0.15,type:'shockSpark'});} }
    
    // Boss AI patterns
    if(e.type==='boss'){
      // slow drift toward top-center (during power-up, drift less and charge)
      moveTo(e, G.W/2 + Math.sin(e.t*0.2)*30, G.H*0.28 + Math.cos(e.t*0.17)*22, dt);
      // timers
      e.cdSmall = Math.max(0, e.cdSmall - dt);
      e.cdBig = Math.max(0, e.cdBig - dt);
      const bb=TUNE.boss.bullet; e.phase = e.phase||0; e.phaseT=(e.phaseT||0)+dt;
      // Power-up phase: no firing for ~5s
      e.powerUp = Math.max(0, (e.powerUp||0) - dt);
      if(e.powerUp>0){
        // mild shake/particles to indicate charge (visualized in render via ring)
        continue;
      }
      // Continuous spiral with slight speed wobble
      if(e.cdSmall<=0){ e.cdSmall = TUNE.boss.patterns.spiralInterval; const arms=TUNE.boss.patterns.spiralArms; const wob=1+0.15*Math.sin(e.t*0.9); for(let i=0;i<arms;i++){ const a = e.t*1.6 + i*(Math.PI*2/arms); const bObj = fireProjectile(e.x,e.y,a, bb.speed*0.9*wob, 6, false, bb.life, bb.spread); if(bObj) bObj.fromBoss=true; } }
      // Big radial burst every few seconds
       if(e.cdBig<=0){ e.cdBig = TUNE.boss.cooldowns.big * (0.8+0.4*Math.random()); const n=TUNE.boss.patterns.radialCount + R.rint(-8,8); for(let i=0;i<n;i++){ const a = i*(Math.PI*2/n) + Math.sin(e.t*0.5)*0.1; (function(){ const bObj=fireProjectile(e.x,e.y,a + e.phase*0.2, bb.speed*0.85, 8, false, bb.life*1.2, 0); if(bObj) bObj.fromBoss=true; })(); } }
      // Occasional walls, phase-shifted
      if(Math.floor(e.t*0.75) % 3===0 && (e.t*0.75-Math.floor(e.t*0.75))<dt){ const rows=TUNE.boss.patterns.wallRows; const spacing=TUNE.boss.patterns.wallSpacing; for(let r=0;r<rows;r++){ const yrow = 80 + r*spacing; (function(){ const bL=fireProjectile(0,yrow,0, bb.speed*0.95, 7, false, bb.life, 0); if(bL) bL.fromBoss=true; const bR=fireProjectile(G.W,yrow,Math.PI, bb.speed*0.95, 7, false, bb.life, 0); if(bR) bR.fromBoss=true; const xcol = 80 + r*spacing; const bU=fireProjectile(xcol,0,Math.PI/2, bb.speed*0.95, 7, false, bb.life, 0); if(bU) bU.fromBoss=true; const bD=fireProjectile(xcol,G.H,-Math.PI/2, bb.speed*0.95, 7, false, bb.life, 0); if(bD) bD.fromBoss=true; })() } }
      // Every ~30s do a large volley similar to opening
      if(e.phaseT>30){ e.phaseT=0; e.phase=(e.phase||0)+1; const n=TUNE.boss.patterns.radialCount; for(let i=0;i<n;i++){ const a=i*(Math.PI*2/n); const bObj=fireProjectile(e.x,e.y,a, bb.speed*0.9, 9, false, bb.life*1.1, 0); if(bObj) bObj.fromBoss=true; } }
      // Rocket cadence: one after another, reduced volume
      e.rocketCD = Math.max(0, (e.rocketCD||0) - dt);
      if(e.rocketCD<=0){ const aim=Math.atan2(player.y-e.y, player.x-e.x); const ro=TUNE.boss.rocketSpeed; const rObj=fireProjectile(e.x,e.y,aim, ro, 18, false, bb.life*3.2, 0, 0, 'rpg'); if(rObj) rObj.fromBoss=true; e.rocketCD = 0.5 + Math.random()*0.7; }
      continue;
    }
    if(e.wep && e.wep.type==='gun'){ // ranged AI: kite band [140,220]
      // TUNE: Ranged enemy preferred distance range (pixels)
      const prefer= TUNE.enemies.preferDist;
      const los=hasLOS(e.x,e.y,player.x,player.y);
      
      // move to maintain distance
      let tx=e.x, ty=e.y; 
      if(dist<prefer.min){ 
        tx=e.x-Math.cos(ang)*TUNE.enemies.retreatDistance;
        ty=e.y-Math.sin(ang)*TUNE.enemies.retreatDistance;
      } else if(dist>prefer.max){ 
        tx=e.x+Math.cos(ang)*TUNE.enemies.approachDistance;
        ty=e.y+Math.sin(ang)*TUNE.enemies.approachDistance; 
      } else {
        // Hold band for ranged enemies
        tx=e.x; ty=e.y;
      }
      
      // TUNE: Strafe distance for ranged enemies
      const side = (R.rand()<.5?1:-1);
      tx += Math.cos(ang+Math.PI/2*side)*TUNE.enemies.strafeAmount;
      ty += Math.sin(ang+Math.PI/2*side)*TUNE.enemies.strafeAmount;
      
      
      // cover seek if no LOS or hurt
      if(!los || e.hp<e.maxhp*TUNE.enemies.coverSeekHealthPct){ // TUNE: Health threshold for seeking cover
        const o=R.pick(obstacles); 
        tx=o.x+o.w*(R.rand()); 
        ty=o.y+o.h*(R.rand()); 
      }
      moveTo(e, tx, ty, dt);
      
      // TUNE: Ranged enemy shooting ranges and cooldowns
      e.cd=Math.max(0,e.cd-dt); e.burstPause=Math.max(0,e.burstPause-dt);
      if(los && dist<TUNE.enemies.shootMaxRange){ // TUNE: Maximum shooting range
        if(e.burstLeft>0 && e.cd<=0){
          shootEnemyGun(e, ang); playSfx(e.wep.key==='rifle'?'rifle':(e.wep.key==='smg'?'smg':(e.wep.key==='shotgun'?'shotgun':'pistol'))); e.burstLeft--; e.cd=(e.wep.key==='smg'?0.06:(e.wep.key==='rifle'?0.18:0.2));
          if(e.burstLeft<=0){ e.burstPause = 0.8 + R.rand()*0.6; }
        } else if(e.cd<=0 && e.burstPause<=0){
          // start a burst
          e.burstLeft = (e.wep.key==='smg'? R.rint(3,6) : (e.wep.key==='rifle'? R.rint(2,3): R.rint(2,4)) );
          e.cd=0; // next frame will fire first shot
        }
      }
    } else if(e.wep && e.wep.type==='melee'){ // melee AI
      // TUNE: Melee enemy predictive pursuit (seconds of lead time)
      const lead=(game.wave<=3?TUNE.enemies.meleeLeadTime.early:(game.wave<=7?TUNE.enemies.meleeLeadTime.mid:TUNE.enemies.meleeLeadTime.late)); // TUNE: Lead time scaling by wave
      const leadX=player.x+player.vx*lead, leadY=player.y+player.vy*lead; 
      moveTo(e, leadX, leadY, dt);
      
      if(dist<e.wep.range - TUNE.enemies.meleeStandOff + e.r + player.r && e.cd<=0){ 
        e.cd=e.wep.cooldown||0.6; 
        if(player.iframes<=0){ 
          // TUNE: Melee enemy damage multiplier (0.8 = 80% of weapon damage)
          damagePlayer(Math.round(e.wep.dmg*TUNE.enemies.meleeDamageMultiplier)); 
          player.iframes=TUNE.player.invincibleSecondsAfterMeleeHit; // TUNE: Player invincibility frames after melee hit
        }
        spawnHitFX(player.x,player.y);
      }
      e.cd=Math.max(0,e.cd-dt);
    } else { 
      moveTo(e, player.x, player.y, dt); 
    }
    
    // player separation: keep small stand-off (melee) or avoid overlap
    const minDist = e.r + player.r + (e.wep && e.wep.type==='melee' ? TUNE.enemies.meleeStandOff : 2);
    if(dist < minDist){
      const nx = (dist>0)? dx/dist : 1, ny = (dist>0)? dy/dist : 0;
      const push = minDist - dist;
      e.x -= nx * push;
      e.y -= ny * push;
    }

    // bounds
    if(e.x<0) e.x=0; if(e.x>WORLD.W) e.x=WORLD.W; if(e.y<0) e.y=0; if(e.y>WORLD.H) e.y=WORLD.H;
  }

  // Quest Enemy and Boss AI (only when in quest interior)
  if(inInterior && currentInterior?.interior?.questEnemies) {
    const interior = currentInterior.interior;
    const boss = interior.npc;
    
    // Update quest enemies
    interior.questEnemies.forEach(enemy => {
      if(!enemy.alive) return;
      
      enemy.lastShot += dt * 1000;
      enemy.t += dt; // Update time tracker
      
      // Handle status effects like regular enemies
      if(enemy.burnT > 0) { 
        enemy.burnT -= dt; 
        if(enemy.burnT <= 0) enemy.burnT = 0;
        else if(Math.floor(enemy.t * 4) % 2 === 0) {
          enemy.hp -= TUNE.status.burn.dps * dt;
          if(enemy.hp <= 0) { enemy.alive = false; game.score += 50; }
        }
      }
      if(enemy.iceT > 0) { enemy.iceT -= dt; if(enemy.iceT <= 0) enemy.iceT = 0; }
      if(enemy.shockT > 0) { enemy.shockT -= dt; if(enemy.shockT <= 0) enemy.shockT = 0; }
      
      const dx = player.x - enemy.x;
      const dy = player.y - enemy.y;
      const dist = Math.hypot(dx, dy);
      const ang = Math.atan2(dy, dx);
      
      // Apply status effect movement penalties
      let moveSpeed = enemy.moveSpeed;
      if(enemy.iceT > 0) moveSpeed *= (TUNE.status.ice.slowMul || 0.5);
      if(enemy.shockT > 0) moveSpeed = 0; // stunned
      
      // Simple AI: move toward player and shoot
      if(dist > 50 && moveSpeed > 0) {
        enemy.x += Math.cos(ang) * moveSpeed * dt;
        enemy.y += Math.sin(ang) * moveSpeed * dt;
      }
      
      // Shoot at player
      if(enemy.lastShot >= enemy.fireRate && dist < 300 && hasLOS(enemy.x, enemy.y, player.x, player.y)) {
        enemy.lastShot = 0;
        fireProjectile(enemy.x, enemy.y, ang, 200, 15, false, 3, 0.1);
      }
      
      // Keep enemy in interior bounds
      const r = interior.rect;
      if(enemy.x < r.x + 20) enemy.x = r.x + 20;
      if(enemy.x > r.x + r.w - 20) enemy.x = r.x + r.w - 20;
      if(enemy.y < r.y + 20) enemy.y = r.y + 20;
      if(enemy.y > r.y + r.h - 20) enemy.y = r.y + r.h - 20;
    });
    
    // Update quest boss
    if(boss && boss.type === 'quest_boss' && boss.questActive && boss.alive) {
      boss.lastShot = (boss.lastShot || 0) + dt * 1000;
      
      // Handle status effects like regular enemies
      if(boss.burnT > 0) { 
        boss.burnT -= dt; 
        if(boss.burnT <= 0) boss.burnT = 0;
        else if(Math.floor((boss.lastShot/1000) * 4) % 2 === 0) {
          boss.hp -= TUNE.status.burn.dps * dt;
          if(boss.hp <= 0) { boss.alive = false; game.score += 500; }
        }
      }
      if(boss.iceT > 0) { boss.iceT -= dt; if(boss.iceT <= 0) boss.iceT = 0; }
      if(boss.shockT > 0) { boss.shockT -= dt; if(boss.shockT <= 0) boss.shockT = 0; }
      
      const dx = player.x - boss.x;
      const dy = player.y - boss.y;
      const dist = Math.hypot(dx, dy);
      const ang = Math.atan2(dy, dx);
      
      // Apply status effect movement penalties
      let baseMoveSpeed = 60;
      if(boss.iceT > 0) baseMoveSpeed *= (TUNE.status.ice.slowMul || 0.5);
      if(boss.shockT > 0) baseMoveSpeed = 0; // stunned
      
      // Boss AI: slower movement, more damage
      const oldX = boss.x, oldY = boss.y;
      if(dist > 80 && baseMoveSpeed > 0) {
        boss.x += Math.cos(ang) * baseMoveSpeed * dt;
        boss.y += Math.sin(ang) * baseMoveSpeed * dt;
      }
      
      // Update boss animation based on movement
      const deltaX = boss.x - boss.lastX;
      const deltaY = boss.y - boss.lastY;
      const isMoving = Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1;
      
      if(isMoving) {
        // Determine direction based on horizontal movement primarily
        if(Math.abs(deltaX) > Math.abs(deltaY)) {
          boss.animDir = deltaX > 0 ? 'right' : 'left';
        } else {
          boss.animDir = 'idle'; // Use idle for vertical movement
        }
        
        // Animate if moving left or right
        if(boss.animDir === 'left' || boss.animDir === 'right') {
          boss.animT += dt;
          if(boss.animT >= TUNE.sprites.enemy.questBoss.step) {
            boss.animT = 0;
            boss.animPhase = !boss.animPhase; // Toggle between frame 1 and 2
          }
        }
      } else {
        boss.animDir = 'idle';
        boss.animT = 0;
        boss.animPhase = false;
      }
      
      // Update last position for next frame
      boss.lastX = boss.x;
      boss.lastY = boss.y;
      
      // Boss shoots more frequently and with more damage
      if(boss.lastShot >= 800 && dist < 400 && hasLOS(boss.x, boss.y, player.x, player.y)) {
        boss.lastShot = 0;
        fireProjectile(boss.x, boss.y, ang, 180, 25, false, 4, 0.05);
      }
      
      // Keep boss in interior bounds
      const r = interior.rect;
      if(boss.x < r.x + 30) boss.x = r.x + 30;
      if(boss.x > r.x + r.w - 30) boss.x = r.x + r.w - 30;
      if(boss.y < r.y + 30) boss.y = r.y + 30;
      if(boss.y > r.y + r.h - 30) boss.y = r.y + r.h - 30;
    }
    
    // Check quest completion
    checkQuestCompletion();
  }

  // Drops (collect coins and vehicle wreck)
for(const d of drops){ if(!d.alive) continue; d.life-=dt; if(d.life<=0) d.alive=false; if(Math.hypot(d.x-player.x,d.y-player.y)<16){ if(d.kind==='coin'){ const extra=(d.coinsExtra||0); const mult=1+0.5*extra; game.coins+=Math.max(1, Math.round(1*mult)); updateShopCoins(); AudioSys.beep('pickup'); } else if(d.kind==='veh_wreck'){ if(!player.inVehicle){ player.inVehicle=true; player.vehicleType='cop_car'; player.vehicleDirection='idle'; const vehHp = TUNE.vehicle.hp * (legacy.totals.carMaster?2.2:1); player.vehicleHp=vehHp; player.r=TUNE.vehicle.radius; } } d.alive=false; } }

  // Particles & floats
  for(const p of particles){
    if(!p.alive) continue;
    // universal lifetime step and hard cap (0.5s)
    p.life = (p.life!=null? p.life : 0.5) - dt;
    if(p.life<=0){ p.alive=false; continue; }
    if(p.type==='hit'){
      ctx.fillStyle='#fff'; ctx.globalAlpha=clamp(p.life/TUNE.fx.hitLife,0,1);
      ctx.beginPath(); ctx.arc(p.x,p.y,5*(1-p.life/TUNE.fx.hitLife),0,TAU); ctx.fill(); ctx.globalAlpha=1;
    } else if(p.type==='smoke'){
      const ml=p.maxLife||0.6; const t=clamp(1-(p.life/ml),0,1); ctx.globalAlpha=0.7*(1-t);
      ctx.fillStyle='#c6d1db'; ctx.beginPath(); ctx.arc(p.x,p.y, 5 + 5*t, 0, TAU); ctx.fill(); ctx.globalAlpha=1;
    } else if(p.type==='smokeTiny'){
      const ml=p.maxLife||0.18; const t=clamp(1-(p.life/ml),0,1); ctx.globalAlpha=0.85*(1-t);
      ctx.fillStyle='#e3e8ef'; ctx.beginPath(); ctx.arc(p.x,p.y, 6 + 8*t, 0, TAU); ctx.fill(); ctx.globalAlpha=1;
    } else if(p.type==='muzzle'){
      const t=clamp(p.life/0.12,0,1); ctx.globalAlpha=0.95*t; const r=16*(1-t);
      const grd=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,r); grd.addColorStop(0,'rgba(255,230,100,0.98)'); grd.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(p.x,p.y,r,0,TAU); ctx.fill(); ctx.globalAlpha=1;
    } else if(p.type==='muzzleCone'){
      const ml=p.maxLife||0.05; const t=clamp(1-(p.life/ml),0,1); ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.a||0);
      ctx.globalAlpha=0.85*(1-t); ctx.fillStyle='#ffd45a'; const L=18, W=6; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(L, W*0.5); ctx.lineTo(L, -W*0.5); ctx.closePath(); ctx.fill(); ctx.restore(); ctx.globalAlpha=1;
    } else if(p.type==='burnSpark'){
      ctx.globalAlpha=0.8; ctx.fillStyle='#ff6b6b'; ctx.beginPath(); ctx.arc(p.x,p.y, 2, 0, TAU); ctx.fill(); ctx.globalAlpha=1;
    } else if(p.type==='iceSpark'){
      ctx.globalAlpha=0.8; ctx.fillStyle='#63d3ff'; ctx.beginPath(); ctx.arc(p.x,p.y, 2.5, 0, TAU); ctx.fill(); ctx.globalAlpha=1;
    } else if(p.type==='shockSpark'){
      ctx.globalAlpha=0.9; ctx.fillStyle='#ffd45a'; ctx.beginPath(); ctx.arc(p.x,p.y, 2, 0, TAU); ctx.fill(); ctx.globalAlpha=1;
    } else if(p.type==='explosion'){
      ctx.globalAlpha=Math.max(0,p.life/0.4); const r=40*(1-p.life/0.4);
      const grd=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,r); grd.addColorStop(0,'#fff6'); grd.addColorStop(0.4,'#ffcf'); grd.addColorStop(1,'#0000');
      ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(p.x,p.y,r,0,TAU); ctx.fill(); ctx.globalAlpha=1;
    }
  }
  for(const f of floats){ f.life-=dt; f.y+=f.vy*dt; }

  // HUD
  setTxt('scoreText', game.score); setTxt('coinsText', game.coins); setTxt('waveText', game.wave);
  setTxt('hpText', Math.max(0,Math.floor(player.hp))); setTxt('hpMaxText', player.hpMax); $('#hpBar').style.transform=`scaleX(${clamp(player.hp/player.hpMax,0,1)})`;
  setTxt('armText', player.armor); $('#armBar').style.transform=`scaleX(${clamp(player.armor/10,0,1)})`;
  $('#stBar').style.transform=`scaleX(${clamp(player.stamina/player.staminaMax,0,1)})`;
  updateWeaponDisplay();
  
  // Update HUD with gang colors if joined
  if(playerGang){
    document.documentElement.style.setProperty('--accent-primary', playerGang.color);
    document.documentElement.style.setProperty('--border-accent', playerGang.color);
    const objHUD = $('#objectivesHUD');
    if(objHUD) objHUD.style.borderColor = playerGang.color;
  }
  // Wanted stars display
  const stars = Math.min(6, Math.ceil(game.wave/5)); 
  const starsContainer = $('#starsContainer'); 
  if(starsContainer){ 
    starsContainer.innerHTML=''; 
    for(let i=0;i<6;i++){ 
      const s=document.createElement('span'); 
      s.textContent = (i<stars)? '★' : '☆'; 
      s.style.marginRight='3px'; 
      s.style.color = (i<stars)? 'var(--accent-danger)' : 'var(--text-muted)'; 
      s.style.textShadow = (i<stars)? '0 0 8px rgba(239, 68, 68, 0.6)' : 'none'; 
      s.style.fontSize = '14px';
      starsContainer.appendChild(s); 
    } 
  }
  // End after wave 30 (disabled for Stage 2 flow)
  if(false){ /* Stage 2 supersedes end-of-run */ }

  // Grapple pull: if anchored, move player toward anchor along a rope and stop near collision
  if(player.grappling){
    const ax=player.grappleX, ay=player.grappleY; const dx=ax-player.x, dy=ay-player.y; const dist=Math.hypot(dx,dy);
    const pullSpeed = 900; // pixels/sec towards the anchor
    if(dist<14){ player.grappling=false; player.grappleBullet=null; }
    else {
      const vx = (dx/dist)*pullSpeed*dt, vy=(dy/dist)*pullSpeed*dt;
      const nx = player.x+vx, ny=player.y+vy;
      // stop at obstacles
      const ph = pathHitObstacle(player.x,player.y,nx,ny, player.r);
      if(ph){ player.x=ph.x; player.y=ph.y; player.grappling=false; player.grappleBullet=null; }
      else { player.x=nx; player.y=ny; }
    }
  }

  // Vehicle interact (enter/exit)
  // Exit current vehicle
  if(keys['f'] && player.inVehicle){ 
    keys['f']=false; 
    parkedVehicles.push({x:player.x,y:player.y,vehicleType:player.vehicleType}); 
    player.inVehicle=false; player.superCar=false; player.vehicleType=null; player.vehicleDirection='idle'; 
    player.r=TUNE.player.radius; 
  }
  // Enter super car (only on foot)
  if(keys['f'] && !player.inVehicle && game.stage===2 && superCar.alive && Math.hypot(player.x-superCar.x, player.y-superCar.y)<24){ 
    keys['f']=false; player.inVehicle=true; player.vehicleType='super_car'; player.vehicleDirection='idle';
    player.vehicleHp=TUNE.superCar.hp; player.r=TUNE.superCar.radius; player.speed=TUNE.player.baseSpeed; player.superCar=true; 
    superCar.alive=false; 
  }
  // Enter parked vehicles (only on foot)
  if(keys['f'] && !player.inVehicle){ 
    for(let i=0;i<parkedVehicles.length;i++){ 
      const v=parkedVehicles[i]; 
      if(Math.hypot(player.x-v.x, player.y-v.y)<24){ 
                 keys['f']=false; player.inVehicle=true; player.vehicleType=v.vehicleType||'super_car'; player.vehicleDirection='idle';
         player.superCar = (v.vehicleType === 'super_car'); 
         // Set vehicle stats based on type
         if(v.vehicleType === 'cop_car') {
           player.vehicleHp = TUNE.vehicle.hp;
           player.r = TUNE.vehicle.radius;
         } else if(v.vehicleType === 'ferrari') {
           player.vehicleHp = TUNE.ferrari.hp;
           player.r = TUNE.ferrari.radius;
         } else if(v.vehicleType === 'armored_van') {
           player.vehicleHp = TUNE.armoredVan.hp;
           player.r = TUNE.armoredVan.radius;
         } else if(v.vehicleType === 'super_car') {
           player.vehicleHp = TUNE.superCar.hp;
           player.r = TUNE.superCar.radius;
         } else {
           player.vehicleHp = TUNE.vehicle.hp;
           player.r = TUNE.vehicle.radius;
         } 
        parkedVehicles.splice(i,1); break; 
      } 
    } 
  }

  // Building door interact
  if(game.stage===2 && !player.inVehicle){ 
    if(!inInterior){ 
      for(const b of buildings){ 
        const d=b.door; 
        if(d && player.x>d.x && player.x<d.x+d.w && player.y>d.y && player.y<d.y+d.h && keys['f']){ 
          keys['f']=false; 
          enterBuilding(b); 
          break; 
        } 
      } 
    } else { 
      // Interior interactions
      
      // T key for NPC interaction
      if(keys['t']){
        keys['t'] = false; // Consume the key press
        const npc = currentInterior?.interior?.npc;
        if(npc && Math.hypot(player.x - npc.x, player.y - npc.y) < npc.interactRadius){
          if(npc.type === 'gang_leader' && !playerGang) {
            showGangDialogue(npc.gang);
          } else if(npc.type === 'gang_leader' && playerGang && playerGang.name === npc.gang.name) {
            showGangDialogue(npc.gang); // Show quest dialogue
          } else if(npc.type === 'shopkeeper') {
            showShop(npc.gang, npc);
          } else if(npc.type === 'quest_boss' && playerGang && playerGang.name === npc.gang.name) {
            startQuestFight(npc);
          }
        }
      }
      
      // F key for door exit
      if(keys['f']){
        keys['f'] = false; // Consume the key press
        const d = currentInterior?.interior?.door; 
        if(d){
          // Check if player is standing on the door
          const playerInDoor = player.x > d.x + 5 && player.x < d.x + d.w - 5 && 
                              player.y > d.y + 5 && player.y < d.y + d.h - 5;
          if(playerInDoor){ 
            exitBuilding(); 
          }
        } 
      }
    }
  }

  // Clamp player within interior bounds if inside
  if(inInterior && currentInterior){ const r=currentInterior.interior.rect; player.x=clamp(player.x, r.x+10, r.x+r.w-10); player.y=clamp(player.y, r.y+10, r.y+r.h-10); }
}

// ========================================
// WEAPON DISPLAY UI - Updates the left-side weapon wheel
// ========================================
function updateWeaponDisplay(){
  const container = $('#weaponDisplay');
  if (!container) return;
  
  container.innerHTML = '';
  
  const ICONS={
    pistol: 'sprites/weapons/weapon_pistol.png',
    smg: 'sprites/weapons/weapon_smg.png',
    shotgun: 'sprites/weapons/weapon_shotgun.png',
    rifle: 'sprites/weapons/weapon_rifle.png',
    sniper: 'sprites/weapons/weapon_sniper.png',
    rpg: 'sprites/weapons/weapon_rpg.png',
    grapple: 'sprites/weapons/weapon_grapple.png',
    shortsword: 'sprites/weapons/weapon_crowbar.png',
    greatsword: 'sprites/weapons/weapon_bat.png',
    // Special Gang Weapons
    desert_eagle: 'sprites/weapons/weapon_desert_eagle.png',
    ak47: 'sprites/weapons/weapon_ak47.png',
    bolt_sniper: 'sprites/weapons/weapon_bolt_sniper.png',
    compact_smg: 'sprites/weapons/weapon_compact_smg.png',
    double_shotgun: 'sprites/weapons/weapon_double_shotgun.png'
  };
  
  // Show only owned weapons
  player.weapons.forEach((w, ownedIndex) => {
    const key = w.key;
    const isEquipped = (ownedIndex===player.weaponIndex);
    const slot = document.createElement('div');
    slot.className = `weapon-slot ${isEquipped ? 'equipped' : ''}`;
    
    const icon = document.createElement('img'); 
    icon.src = ICONS[key]; 
    icon.className = 'weapon-icon';
    icon.alt = key;
    
    const info = document.createElement('div');
    info.className = 'weapon-info';
    
    const name = document.createElement('div'); 
    name.className = 'weapon-name'; 
    name.textContent = w.name || TUNE.weapons[key].name;
    
    const stats = document.createElement('div'); 
    stats.className = 'weapon-stats';
    if (TUNE.weapons[key].type === 'gun') {
      stats.textContent = `${w.dmg||TUNE.weapons[key].dmg} DMG • ${w.rpm||TUNE.weapons[key].rpm} RPM`;
    } else {
      stats.textContent = `${w.dmg||TUNE.weapons[key].dmg} DMG • ${w.range||TUNE.weapons[key].range} RNG`;
    }
    
    const ammo = document.createElement('div'); 
    ammo.className = 'weapon-ammo';
    if (TUNE.weapons[key].type === 'gun') {
      ammo.textContent = `${w.ammo}/${w.mag}`;
    } else {
      ammo.textContent = 'MELEE';
    }
    
    info.appendChild(name); 
    info.appendChild(stats); 
    info.appendChild(ammo);
    slot.appendChild(icon); 
    slot.appendChild(info);
    
    slot.onclick = () => {
      player.weaponIndex = ownedIndex; 
      updateWeaponDisplay();
    };
    
    container.appendChild(slot);
  });
}

// ========================================
// ENEMY MOVEMENT & SPEED SCALING - TUNE THESE VALUES
// ========================================
// TUNE: Enemy movement speed multipliers by wave and difficulty
function moveTo(e, tx, ty, dt){ 
  // desired direction
  let dx=tx-e.x, dy=ty-e.y; 
  // pick a temporary corner waypoint if LOS blocked
  if(!hasLOS(e.x,e.y,tx,ty)){ const wp=navAround(e,tx,ty); if(wp){ dx=wp.x-e.x; dy=wp.y-e.y; } }
  let d=Math.hypot(dx,dy)||1; 

  // Smooth wave speed multiplier: linear ramp from early->lateCap by target wave 20
  const mw=TUNE.enemies.moveWaveMul;
  const t = clamp((game.wave-1)/Math.max(1,(TUNE.enemies.speedRampTargetWave-1)), 0, 1);
  const waveMul = clamp(mw.early + (mw.lateCap - mw.early) * t, mw.early, mw.lateCap);
  let sp=e.speed*(game.difficulty?TUNE.difficulty.enemySpeedMulHard:1)*waveMul; if(e.iceT>0){ sp*= (TUNE.status.ice.slowMul||0.5); } if(e.shockT>0){ sp=0; } sp=Math.min(sp, TUNE.enemies.maxSpeed);

  // Obstacle avoidance: sample a few steering candidates around desired angle
  const baseAng = Math.atan2(dy,dx);
  let bestAng = baseAng, bestScore = -1;
  // Desired forward vector
  let vx = Math.cos(baseAng), vy = Math.sin(baseAng);

  // Obstacle repulsion: accumulate pushes from nearby rectangles
  const A = TUNE.enemies.avoid;
  let rx=0, ry=0;
  for(const o of obstacles){
    // sample closest point on rect to enemy
    const cx = clamp(e.x, o.x, o.x+o.w);
    const cy = clamp(e.y, o.y, o.y+o.h);
    const ddx = e.x-cx, ddy = e.y-cy;
    const dist = Math.hypot(ddx,ddy);
    const range = A.radius + e.r;
    if(dist < range && dist>0){
      const push = (1 - dist/range);
      rx += (ddx/dist) * push;
      ry += (ddy/dist) * push;
    }
  }

  // Blend desired with repulsion
  vx = vx + rx * A.weight;
  vy = vy + ry * A.weight;
  const mag = Math.hypot(vx,vy) || 1; vx/=mag; vy/=mag;

  // Advance
  e.x += vx*sp*dt;
  e.y += vy*sp*dt; 
  resolveCircleObstacles(e);
}

function meleeSwing(wep){ // arc hit in front of player
  const a0=player.facing-wep.arc/2, a1=player.facing+wep.arc/2; const Rng=wep.range+player.r+2;
  for(const e of enemies){ if(!e.alive) continue; const ang=Math.atan2(e.y-player.y, e.x-player.x); let da=((ang-a0)%(TAU)+TAU)%TAU; let da2=((a1-a0)%(TAU)+TAU)%TAU; if(da<=da2 && Math.hypot(e.x-player.x,e.y-player.y)<=Rng+e.r){ damageEnemy(e, Math.round(wep.dmg*dmgMod())); }
  }
  spawnHitFX(player.x+Math.cos(player.facing)*Rng, player.y+Math.sin(player.facing)*Rng);
}

// ========================================
// ENEMY WEAPON FIRING - TUNE THESE VALUES
// ========================================
// TUNE: Enemy weapon damage, projectile speeds, and properties
function shootEnemyGun(e, ang){ 
  const k=e.wep.key; 
  if(k==='shotgun'){
    const g=TUNE.enemyGuns.shotgun; fireShotgun(e.x,e.y,ang,g.pellets,g.spread,g.speed,g.dmg,false);
  } else if(k==='rifle'){
    const g=TUNE.enemyGuns.rifle; const c=Math.min(3, g.count||1); for(let i=0;i<c;i++) fireProjectile(e.x,e.y,ang + (i-(c-1)/2)*(g.spread*Math.PI/180)/Math.max(1,c-1), g.speed, g.dmg, false, g.life, g.spread);
  } else if(k==='smg'){
    const g=TUNE.enemyGuns.smg; const c=Math.min(3, g.count||1); for(let i=0;i<c;i++) fireProjectile(e.x,e.y,ang + (i-(c-1)/2)*(g.spread*Math.PI/180)/Math.max(1,c-1), g.speed, g.dmg, false, g.life, g.spread);
  } else {
    const g=TUNE.enemyGuns.pistol; const c=g.count||1; for(let i=0;i<c;i++) fireProjectile(e.x,e.y,ang + (i-(c-1)/2)*(g.spread*Math.PI/180)/Math.max(1,c-1), g.speed, g.dmg, false, g.life, g.spread);
  }  
  // Tiny muzzle flash and smoke puff at enemy muzzle
  { const mx = e.x + Math.cos(ang)* (e.r+5); const my = e.y + Math.sin(ang)* (e.r+5);
    particles.push({alive:true,x:mx,y:my,vx:0,vy:0,life:0.05,type:'muzzle'});
    particles.push({alive:true,x:mx,y:my-8,vx:(R.rand()*2-1)*8,vy:(R.rand()*2-1)*8,life:0.14,maxLife:0.14,type:'smokeTiny'});
    particles.push({alive:true,x:mx,y:my,a:ang,life:0.05,maxLife:0.05,type:'muzzleCone'});
  }
}

// -----------------------------
// Render
// -----------------------------
function render(){
  // shake
  let ox=0, oy=0; if(shakeT>0){ shakeT-=1/60; ox=(Math.random()*2-1)*shakeMag; oy=(Math.random()*2-1)*shakeMag; }
  ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,G.W,G.H); ctx.save(); ctx.translate(ox,oy);
    // arena
  ctx.fillStyle='#0b111c'; ctx.fillRect(0,0,G.W,G.H);
  updateCamera(1/60);
  // world-space transform
  ctx.save();
  ctx.scale(camera.zoom, camera.zoom);
  ctx.translate(-camera.x, -camera.y);
  // tiled background per zone
  const bg = document.getElementById('bgImg');
  const hasBg = isImageReady(bg);
  
  // Interior background
  if(inInterior && currentInterior){
    const r = currentInterior.interior.rect;
    const npc = currentInterior.interior.npc;
    let interiorBg = null;
    
    // Determine which interior background to use
    if(npc && npc.type === 'gang_leader' && npc.gang){
      // Gang HQ interiors
      if(npc.gang.leader === 'A Pimp Named Slickback') interiorBg = document.getElementById('interiorUptownHQ');
      else if(npc.gang.leader === 'Deebo') interiorBg = document.getElementById('interiorComptonHQ');
      else if(npc.gang.leader === 'Smokey') interiorBg = document.getElementById('interiorHollywoodHQ');
      else if(npc.gang.leader === 'Craig') interiorBg = document.getElementById('interiorDowntownHQ');
    } else if(npc && npc.type === 'shopkeeper'){
      // Shop interior
      interiorBg = document.getElementById('interiorShop');
    }
    
    if(interiorBg && isImageReady(interiorBg)){
      // Draw the interior background image
      ctx.drawImage(interiorBg, 0, 0, interiorBg.naturalWidth, interiorBg.naturalHeight, 
                    r.x, r.y, r.w, r.h);
    } else {
      // Fallback to original rendered background
      ctx.fillStyle = '#0a0c10';
      ctx.fillRect(r.x, r.y, r.w, r.h);
      
      // Floor pattern
      ctx.fillStyle = '#151922';
      const tileSize = 40;
      for(let y = r.y; y < r.y + r.h; y += tileSize){
        for(let x = r.x; x < r.x + r.w; x += tileSize){
          if((Math.floor((x-r.x)/tileSize) + Math.floor((y-r.y)/tileSize)) % 2 === 0){
            ctx.fillRect(x, y, tileSize, tileSize);
          }
        }
      }
      
      // Gang color accent walls
      if(npc && npc.gang){
        ctx.fillStyle = npc.gang.color + '22';
        ctx.fillRect(r.x, r.y, r.w, 80);
      }
    }
  }
  else if(game.stage===1){
    const scale = TUNE.background.tileScale || 1;
    const tw = Math.max(8, Math.floor((bg.naturalWidth||256) * scale));
    const th = Math.max(8, Math.floor((bg.naturalHeight||256) * scale));
    ctx.save(); ctx.globalAlpha = TUNE.background.alpha ?? 0.7;
    for(let y=0;y<G.H;y+=th){ for(let x=0;x<G.W;x+=tw){ ctx.drawImage(bg, 0,0,bg.naturalWidth,bg.naturalHeight, x, y, tw, th); } }
    ctx.restore();
    ctx.strokeStyle='rgba(13,22,36,0.5)'; ctx.lineWidth=1; ctx.beginPath(); for(let x=0;x<G.W;x+=40){ctx.moveTo(x,0); ctx.lineTo(x,G.H);} for(let y=0;y<G.H;y+=40){ctx.moveTo(0,y); ctx.lineTo(G.W,y);} ctx.stroke();
     } else {
    // Stage 2: Use biome-based rendering system
    renderBiomes();
  }
  // Boss health bar (top center)
  { const boss = enemies.find(e=>e.alive && e.type==='boss');
    if(boss){ const pct = clamp(boss.hp/Math.max(1,boss.maxhp),0,1);
      const barW = 820, barH = 16; const x=(G.W-barW)/2, y=8;
      ctx.fillStyle='#121826'; ctx.fillRect(x-2,y-2,barW+4,barH+4);
      ctx.fillStyle='#0a0f18'; ctx.fillRect(x,y,barW,barH);
      ctx.fillStyle=TUNE.boss.color||'#ffcc33'; ctx.fillRect(x,y,barW*pct,barH);
      ctx.strokeStyle='#223045'; ctx.lineWidth=2; ctx.strokeRect(x,y,barW,barH);
      ctx.fillStyle='#e7eef7'; ctx.font='bold 14px system-ui, sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(boss.bossName||'BOSS', x+barW/2, y+barH/2);
    }
  }
  
  // Quest Boss health bar (top center) - only when quest is active
  if(inInterior && currentInterior?.interior?.npc) {
    const questBoss = currentInterior.interior.npc;
    if(questBoss && questBoss.type === 'quest_boss' && questBoss.alive && questBoss.questActive) {
      const pct = clamp(questBoss.hp/Math.max(1,questBoss.maxhp),0,1);
      const barW = 820, barH = 16; const x=(G.W-barW)/2, y=8;
      ctx.fillStyle='#2a1826'; ctx.fillRect(x-2,y-2,barW+4,barH+4);
      ctx.fillStyle='#1a0f18'; ctx.fillRect(x,y,barW,barH);
      ctx.fillStyle='#ff4444'; ctx.fillRect(x,y,barW*pct,barH);
      ctx.strokeStyle='#8b0000'; ctx.lineWidth=2; ctx.strokeRect(x,y,barW,barH);
      ctx.fillStyle='#e7eef7'; ctx.font='bold 14px system-ui, sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      
      // Get boss name based on type
      let bossName = 'QUEST BOSS';
      switch(questBoss.bossType) {
        case 'sex_trafficker': bossName = 'SEX TRAFFICKER'; break;
        case 'chain_snatcher': bossName = 'CHAIN SNATCHER'; break;
        case 'rainbow_hippie': bossName = 'RAINBOW HIPPIE'; break;
        case 'fake_king': bossName = 'FAKE KING'; break;
      }
      
      ctx.fillText(bossName, x+barW/2, y+barH/2);
    }
  }
  // obstacles (invisible unless debug)
  if(TUNE.obstacles.drawDebug){ 
    ctx.fillStyle='#102136'; 
    if(inInterior && currentInterior){
      currentInterior.interior.obstacles.forEach(o=>ctx.fillRect(o.x,o.y,o.w,o.h));
    } else {
      obstacles.forEach(o=>ctx.fillRect(o.x,o.y,o.w,o.h)); 
    }
  }
  
  // Interior-specific rendering
  if(inInterior && currentInterior){
    const interior = currentInterior.interior;
    
    // Interior obstacles (furniture, etc)
    ctx.fillStyle = '#1a2332';
    interior.obstacles.forEach(o => {
      ctx.fillRect(o.x, o.y, o.w, o.h);
      // Add some depth
      ctx.fillStyle = '#0f1420';
      ctx.fillRect(o.x + 2, o.y + 2, o.w - 4, 4);
      ctx.fillStyle = '#1a2332';
    });
    
    // Exit door with frame and visual details
    const door = interior.door;
    
    // Door frame (darker brown)
    ctx.fillStyle = '#654321';
    ctx.fillRect(door.x - 4, door.y - 4, door.w + 8, door.h + 8);
    
    // Door itself (wood color)
    ctx.fillStyle = '#8b7355';
    ctx.fillRect(door.x, door.y, door.w, door.h);
    
    // Door panels (decorative)
    ctx.fillStyle = '#a0865c';
    ctx.fillRect(door.x + 4, door.y + 2, door.w - 8, door.h/2 - 3);
    ctx.fillRect(door.x + 4, door.y + door.h/2 + 1, door.w - 8, door.h/2 - 3);
    
    // Door handle (golden)
    ctx.fillStyle = '#ffd166';
    ctx.beginPath();
    ctx.arc(door.x + door.w - 12, door.y + door.h/2, 3, 0, TAU);
    ctx.fill();
    
    // Door threshold (darker at bottom)
    ctx.fillStyle = '#444';
    ctx.fillRect(door.x - 2, door.y + door.h - 2, door.w + 4, 4);
    
    // Interactive zone indicator on floor
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#ffd166';
    ctx.fillRect(door.x - 10, door.y + door.h, door.w + 20, 15);
    ctx.globalAlpha = 1;
    
    // Subtle glow effect around door
    ctx.globalAlpha = 0.1;
    ctx.fillStyle = '#ffd166';
    ctx.fillRect(door.x - 8, door.y - 8, door.w + 16, door.h + 16);
    ctx.globalAlpha = 1;
  }

  // Bridges are now rendered as part of the biome system

  // Draw buildings and vehicles in world (overworld only)
  if(game.stage===2 && !inInterior){ 
    buildings.forEach(b=>{ 
      // Building structure - different colors for different types
      let buildingColor, outlineColor;
      if(b.type === 'shop') {
        buildingColor = '#2d4a2d';
        outlineColor = '#3d5a3d';
      } else if(b.type === 'quest') {
        buildingColor = '#4a2d2d'; // Darker red for quest buildings
        outlineColor = '#5a3d3d';
      } else {
        buildingColor = '#223045'; // Default HQ color
        outlineColor = '#334455';
      }
      
      ctx.fillStyle = buildingColor; 
      ctx.fillRect(b.x,b.y,b.w,b.h); 
      
      // Building outline
      ctx.strokeStyle = outlineColor;
      ctx.lineWidth = 2;
      ctx.strokeRect(b.x,b.y,b.w,b.h);
      
      // Building type indicator
      if(b.type === 'shop') {
        ctx.fillStyle = '#ffd166';
        ctx.font = 'bold 24px system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('$', b.x + b.w/2, b.y + 30);
      } else if(b.type === 'quest') {
        ctx.fillStyle = '#ff6b6b';
        ctx.font = 'bold 24px system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('!', b.x + b.w/2, b.y + 30);
      }
      
      // Door
      const d=b.door;
      const playerNearDoor = Math.hypot(player.x - (d.x + d.w/2), player.y - (d.y + d.h/2)) < 80;
      
      // Door glow effect if player is near
      if(playerNearDoor){
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#ffd166';
      }
      
      ctx.fillStyle='#8b7355'; 
      ctx.fillRect(d.x,d.y,d.w,d.h); 
      ctx.fillStyle='#ffd166'; 
      ctx.fillRect(d.x+4,d.y+4,d.w-8,d.h-8);
      
      ctx.shadowBlur = 0;
      
      // Door interaction prompt
      if(playerNearDoor && !player.inVehicle){
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(d.x - 20, d.y - 30, d.w + 40, 20);
        
        ctx.fillStyle = '#ffd166';
        ctx.font = 'bold 12px system-ui, sans-serif';
        ctx.textAlign = 'center';
        let enterText;
        if(b.type === 'shop') {
          enterText = '[F] Enter Shop';
        } else if(b.type === 'quest') {
          enterText = '[F] Quest Building';
        } else {
          enterText = '[F] Enter';
        }
        ctx.fillText(enterText, d.x + d.w/2, d.y - 18);
      }
    }); 
  }
  if(game.stage===2){ if(superCar.alive){ const v=$('#superCarIdle'); if(isImageReady(v)){ const vs=TUNE.superCar; const w=v.naturalWidth*vs.scale, h=v.naturalHeight*vs.scale; ctx.drawImage(v, superCar.x-w/2, superCar.y-h/2+vs.offsetY, w, h); } else { ctx.fillStyle='#61dafb'; ctx.beginPath(); ctx.rect(superCar.x-14,superCar.y-8,28,16); ctx.fill(); } } ctx.fillStyle='#61dafb'; parkedVehicles.forEach(v=>{ ctx.beginPath(); ctx.rect(v.x-12, v.y-7, 24, 14); ctx.fill(); }); }

  // drops (with bag sprite and vehicle wreck)
  const bag=$('#bagImg'), vw=$('#vWreck');
  for(const d of drops){ if(!d.alive) continue; if(d.kind==='coin' && isImageReady(bag)){ const s=TUNE.sprites.bag; const w=bag.naturalWidth*(s.scale||0.5), h=bag.naturalHeight*(s.scale||0.5); ctx.drawImage(bag, d.x-w/2, d.y-h/2, w, h); }
    else if(d.kind==='veh_wreck' && isImageReady(vw)){ const vs=TUNE.vehicle; const w=vw.naturalWidth*vs.scale, h=vw.naturalHeight*vs.scale; ctx.drawImage(vw, d.x-w/2, d.y-h/2+vs.offsetY, w, h); }
    else { ctx.fillStyle=d.kind==='coin'? '#ffd166':'#fff'; ctx.beginPath(); ctx.arc(d.x,d.y,3,0,TAU); ctx.fill(); } }

  // bullets
  for(const b of bullets){ if(!b.alive) continue; if(TUNE.bullets.drawTrails){ ctx.strokeStyle = (b.friendly?'#9cff57':'#ff7676'); ctx.globalAlpha=TUNE.bullets.trailAlpha; ctx.lineWidth=TUNE.bullets.trailWidth; ctx.beginPath(); ctx.moveTo(b.lx||b.x, b.ly||b.y); ctx.lineTo(b.x,b.y); ctx.stroke(); ctx.globalAlpha=1; }
    // draw rope for grapple
    if(b.from==='grapple' && b.friendly && b.ropePts && b.ropePts.length>1){ ctx.strokeStyle='#d9dee6'; ctx.lineWidth=2; ctx.beginPath(); const rs=b.ropePts; ctx.moveTo(player.x,player.y); for(const pt of rs){ ctx.lineTo(pt.x,pt.y); } ctx.lineTo(b.x,b.y); ctx.stroke(); }
    ctx.fillStyle=b.color||'#c7cbd1'; ctx.beginPath(); const visR = (b.friendly?TUNE.bullets.friendlyRadius:TUNE.bullets.enemyRadius) * 0.6; ctx.arc(b.x,b.y, visR, 0,TAU); ctx.fill(); }
  

  // enemies
  for(const e of enemies){ if(!e.alive) continue;
    if(e.type==='boss'){
      const cfg=TUNE.sprites.enemy.boss||{scale:1,offsetY:0};
      const img = (e.bossName==='Trevor')? document.getElementById('bTrevor') : document.getElementById('bFranklin');
      if(isImageReady(img)){ const base=(cfg.scale||1); const scaleAdj=(game.stage===2?0.9:1); const w=img.naturalWidth*base*scaleAdj, h=img.naturalHeight*base*scaleAdj; ctx.drawImage(img, e.x-w/2, e.y-h/2+(cfg.offsetY||0), w, h); }
      else { ctx.fillStyle=TUNE.boss.color||'#ffcc33'; ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,TAU); ctx.fill(); }
      ctx.fillStyle='#222'; ctx.fillRect(e.x-16,e.y-e.r-14,32,4); ctx.fillStyle=TUNE.boss.color||'#ffcc33'; ctx.fillRect(e.x-16,e.y-e.r-14,32*(e.hp/e.maxhp),4);
      continue;
    }
    if(e.type==='grunt'){
      const cfg=TUNE.sprites.enemy.grunt, gi=$('#gIdle'), gl=$('#gLeft'), gr=$('#gRight');
      const dirX = Math.cos(e.aim||0);
      if(Math.abs(dirX)>0.2){ e.animOn=true; e.animDir = (dirX<0?'left':'right'); } else { e.animOn=false; e.animDir='idle'; }
      let draw=gi, scl=(cfg.scale||1), offY=(cfg.offsetY||0);
      if(e.animOn){ if(e.animDir==='left'){ draw= gl; scl= (cfg.scaleLeft||cfg.scale||1); offY = ((cfg.offsetLeftY!=null?cfg.offsetLeftY:cfg.offsetY)||0);} else { draw= gr; scl= (cfg.scaleRight||cfg.scale||1); offY = ((cfg.offsetRightY!=null?cfg.offsetRightY:cfg.offsetY)||0);} } else { draw=gi; scl=(cfg.scaleIdle||cfg.scale||1); offY=((cfg.offsetIdleY!=null?cfg.offsetIdleY:cfg.offsetY)||0);} 
      if(isImageReady(draw)){ const w=draw.naturalWidth*scl, h=draw.naturalHeight*scl; ctx.drawImage(draw, e.x-w/2, e.y-h/2+offY, w, h); }
      else { ctx.fillStyle='#ff5555'; ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,TAU); ctx.fill(); }
      // hp bar
      ctx.fillStyle='#222'; ctx.fillRect(e.x-10,e.y-e.r-8,20,3); ctx.fillStyle='#2be'; ctx.fillRect(e.x-10,e.y-e.r-8,20*(e.hp/e.maxhp),3);
    } else if(e.type==='swarmer' || e.type==='smger' || e.type==='shooter' || e.type==='rifler'){
      // use swarmer sprite set for all rushers/gunmen (can be split later)
      const cfg=TUNE.sprites.enemy.swarmer, si=$('#sIdle'), sl=$('#sLeft'), sr=$('#sRight'), su=$('#sUp'), sd=$('#sDown');
      const dirX = Math.cos(e.aim||0), dirY = Math.sin(e.aim||0);
      let draw=si, scl=(cfg.scale||1), offY=(cfg.offsetY||0);
      if(Math.abs(dirX)>Math.abs(dirY)) draw=(dirX<0? sl: sr); else draw=(dirY<0? su: sd);
      if(isImageReady(draw)){ const w=draw.naturalWidth*scl, h=draw.naturalHeight*scl; ctx.drawImage(draw, e.x-w/2, e.y-h/2+offY, w, h); } else { ctx.fillStyle='#ff5555'; ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,TAU); ctx.fill(); }
      ctx.fillStyle='#222'; ctx.fillRect(e.x-10,e.y-e.r-8,20,3); ctx.fillStyle='#2be'; ctx.fillRect(e.x-10,e.y-e.r-8,20*(e.hp/e.maxhp),3);
    } else if(e.type==='tank'){
      const cfg=TUNE.sprites.enemy.tank, ti=$('#tIdle'), tl=$('#tLeft'), tr=$('#tRight'), tu=$('#tUp'), td=$('#tDown');
      const dirX = Math.cos(e.aim||0), dirY = Math.sin(e.aim||0);
      let draw=ti, scl=(cfg.scale||1), offY=(cfg.offsetY||0);
      if(Math.abs(dirX)>Math.abs(dirY)) draw=(dirX<0? tl: tr); else draw=(dirY<0? tu: td);
      if(isImageReady(draw)){ const w=draw.naturalWidth*scl, h=draw.naturalHeight*scl; ctx.drawImage(draw, e.x-w/2, e.y-h/2+offY, w, h); } else { ctx.fillStyle='#aa6f39'; ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,TAU); ctx.fill(); }
      ctx.fillStyle='#222'; ctx.fillRect(e.x-10,e.y-e.r-8,20,3); ctx.fillStyle='#2be'; ctx.fillRect(e.x-10,e.y-e.r-8,20*(e.hp/e.maxhp),3);
    } else {
      ctx.fillStyle=(e.type==='tank')?'#aa6f39':(e.type==='swarmer'?'#c44dff':'#ff5555'); ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,TAU); ctx.fill(); // hp bar
      ctx.fillStyle='#222'; ctx.fillRect(e.x-10,e.y-e.r-8,20,3); ctx.fillStyle='#2be'; ctx.fillRect(e.x-10,e.y-e.r-8,20*(e.hp/e.maxhp),3);
    }
  }

  // Draw boss power-up ring if charging
  { const b=enemies.find(z=>z.alive && z.type==='boss' && (z.powerUp||0)>0); if(b){ const t=clamp((b.powerUp||0)/5,0,1); ctx.save(); ctx.globalAlpha=0.75*(0.4+0.6*t); ctx.strokeStyle=TUNE.boss.color||'#ffcc33'; ctx.lineWidth=3; ctx.beginPath(); const rr=b.r+8+(1-t)*30; ctx.arc(b.x,b.y,rr,0,TAU); ctx.stroke(); ctx.restore(); } }
   
  // player/vehicle sprite
  if(player.inVehicle && player.vehicleType){ 
    // Get the correct sprite based on vehicle type and direction
    let vehicleSprite = null;
    let vehicleConfig = null;
    
         if(player.vehicleType === 'cop_car') {
       vehicleConfig = TUNE.vehicle;
       switch(player.vehicleDirection) {
         case 'left': vehicleSprite = $('#copCarLeft'); break;
         case 'right': vehicleSprite = $('#copCarRight'); break;
         case 'up': vehicleSprite = $('#copCarUp'); break;
         case 'down': vehicleSprite = $('#copCarDown'); break;
         default: vehicleSprite = $('#copCarIdle'); break;
       }
     } else if(player.vehicleType === 'super_car') {
       vehicleConfig = TUNE.superCar;
       switch(player.vehicleDirection) {
         case 'left': vehicleSprite = $('#superCarLeft'); break;
         case 'right': vehicleSprite = $('#superCarRight'); break;
         case 'up': vehicleSprite = $('#superCarUp'); break;
         case 'down': vehicleSprite = $('#superCarDown'); break;
         default: vehicleSprite = $('#superCarIdle'); break;
       }
     } else if(player.vehicleType === 'ferrari') {
       vehicleConfig = TUNE.ferrari;
       switch(player.vehicleDirection) {
         case 'left': vehicleSprite = $('#ferrariLeft'); break;
         case 'right': vehicleSprite = $('#ferrariRight'); break;
         case 'up': vehicleSprite = $('#ferrariUp'); break;
         case 'down': vehicleSprite = $('#ferrariDown'); break;
         default: vehicleSprite = $('#ferrariIdle'); break;
       }
     } else if(player.vehicleType === 'armored_van') {
       vehicleConfig = TUNE.armoredVan;
       switch(player.vehicleDirection) {
         case 'left': vehicleSprite = $('#armoredVanLeft'); break;
         case 'right': vehicleSprite = $('#armoredVanRight'); break;
         case 'up': vehicleSprite = $('#armoredVanUp'); break;
         case 'down': vehicleSprite = $('#armoredVanDown'); break;
         default: vehicleSprite = $('#armoredVanIdle'); break;
       }
     }
    
    // Draw the vehicle sprite
    if(isImageReady(vehicleSprite) && vehicleConfig){ 
      const w=vehicleSprite.naturalWidth*vehicleConfig.scale, h=vehicleSprite.naturalHeight*vehicleConfig.scale; 
      ctx.drawImage(vehicleSprite, player.x-w/2, player.y-h/2+vehicleConfig.offsetY, w, h); 
    } else { 
      // Fallback rendering
      ctx.fillStyle='#61dafb'; ctx.beginPath(); ctx.rect(player.x-10,player.y-6,20,12); ctx.fill(); 
    } 
  }
  else {
    const sp=TUNE.sprites.player||{scale:1,offsetY:0}; const sImgIdle=$('#pIdle'), sImgL=$('#pLeft'), sImgR=$('#pRight');
    // pick frame: alternate idle <-> dir every step while moving
    let draw = sImgIdle; let scl=(sp.scale||1); let offY=(sp.offsetY||0);
    if(game.stage===2){ scl *= 0.8; }
    if(player.animOn){
      const phase = player.animPhase;
      if(player.animDir==='left'){
        draw = phase? sImgIdle : sImgL;
        scl = phase? (sp.scaleIdle||sp.scale||1) : (sp.scaleLeft||sp.scale||1);
        if(game.stage===2){ scl *= 0.8; }
        offY  = phase? ((sp.offsetIdleY!=null?sp.offsetIdleY:sp.offsetY)||0) : ((sp.offsetLeftY!=null?sp.offsetLeftY:sp.offsetY)||0);
      } else if(player.animDir==='right'){
        draw = phase? sImgIdle : sImgR;
        scl = phase? (sp.scaleIdle||sp.scale||1) : (sp.scaleRight||sp.scale||1);
        if(game.stage===2){ scl *= 0.8; }
        offY  = phase? ((sp.offsetIdleY!=null?sp.offsetIdleY:sp.offsetY)||0) : ((sp.offsetRightY!=null?sp.offsetRightY:sp.offsetY)||0);
      }
    } else {
      draw = sImgIdle; scl=(sp.scaleIdle||sp.scale||1); if(game.stage===2){ scl*=0.8; } offY=((sp.offsetIdleY!=null?sp.offsetIdleY:sp.offsetY)||0);
    }
    if(isImageReady(draw)){ const w=(draw.naturalWidth||64)*scl, h=(draw.naturalHeight||64)*scl; ctx.drawImage(draw, player.x-w/2, player.y-h/2+offY, w, h); }
    else { ctx.fillStyle='#61dafb'; ctx.beginPath(); ctx.arc(player.x,player.y,player.r,0,TAU); ctx.fill(); }
  }
  // crosshair
  ctx.strokeStyle='#ffffffbb'; ctx.beginPath(); ctx.moveTo(mouse.x-6,mouse.y); ctx.lineTo(mouse.x+6,mouse.y); ctx.moveTo(mouse.x,mouse.y-6); ctx.lineTo(mouse.x,mouse.y+6); ctx.stroke();

  // particles
  for(const p of particles){
    if(!p.alive) continue;
    if(p.type==='smoke'){
      const ml=p.maxLife||0.6; const t=clamp(1-(p.life/ml),0,1);
      ctx.globalAlpha=0.7*(1-t); ctx.fillStyle='#c6d1db'; ctx.beginPath(); ctx.arc(p.x,p.y, 5 + 5*t, 0, TAU); ctx.fill(); ctx.globalAlpha=1;
    } else if(p.type==='smokeTiny'){
      const ml=p.maxLife||0.18; const t=clamp(1-(p.life/ml),0,1);
      ctx.globalAlpha=0.85*(1-t); ctx.fillStyle='#e3e8ef'; ctx.beginPath(); ctx.arc(p.x,p.y, 6 + 8*t, 0, TAU); ctx.fill(); ctx.globalAlpha=1;
    } else if(p.type==='muzzle'){
      const t=clamp(p.life/0.12,0,1); ctx.globalAlpha=0.95*t; const r=16*(1-t);
      const grd=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,r); grd.addColorStop(0,'rgba(255,230,100,0.98)'); grd.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(p.x,p.y,r,0,TAU); ctx.fill(); ctx.globalAlpha=1;
    } else if(p.type==='muzzleCone'){
      const ml=p.maxLife||0.05; const t=clamp(1-(p.life/ml),0,1); ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.a||0);
      ctx.globalAlpha=0.85*(1-t); ctx.fillStyle='#ffd45a'; const L=18, W=6; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(L, W*0.5); ctx.lineTo(L, -W*0.5); ctx.closePath(); ctx.fill(); ctx.restore(); ctx.globalAlpha=1;
    } else if(p.type==='burnSpark'){
      ctx.globalAlpha=0.8; ctx.fillStyle='#ff6b6b'; ctx.beginPath(); ctx.arc(p.x,p.y, 2, 0, TAU); ctx.fill(); ctx.globalAlpha=1;
    } else if(p.type==='iceSpark'){
      ctx.globalAlpha=0.8; ctx.fillStyle='#63d3ff'; ctx.beginPath(); ctx.arc(p.x,p.y, 2.5, 0, TAU); ctx.fill(); ctx.globalAlpha=1;
    } else if(p.type==='shockSpark'){
      ctx.globalAlpha=0.9; ctx.fillStyle='#ffd45a'; ctx.beginPath(); ctx.arc(p.x,p.y, 2, 0, TAU); ctx.fill(); ctx.globalAlpha=1;
    } else if(p.type==='explosion'){
      ctx.globalAlpha=Math.max(0,p.life/0.4); const r=40*(1-p.life/0.4);
      const grd=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,r); grd.addColorStop(0,'#fff6'); grd.addColorStop(0.4,'#ffcf'); grd.addColorStop(1,'#0000');
      ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(p.x,p.y,r,0,TAU); ctx.fill(); ctx.globalAlpha=1;
    }
  }

  // floats
  ctx.font='12px system-ui, sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  for(const f of floats){ if(f.life<=0) continue; ctx.globalAlpha=Math.max(0,f.life); ctx.fillStyle=f.color; ctx.fillText(f.t, f.x, f.y); }
  ctx.globalAlpha=1;

  // Draw NPCs in interiors
  if(inInterior && currentInterior?.interior?.npc){
    const npc = currentInterior.interior.npc;
    const playerDist = Math.hypot(player.x - npc.x, player.y - npc.y);
    const canInteract = playerDist < npc.interactRadius && 
                       ((npc.type === 'gang_leader' && !playerGang) || npc.type === 'shopkeeper');
    
    // NPC interaction range indicator
    if(canInteract){
      ctx.globalAlpha = 0.2;
      ctx.fillStyle = npc.type === 'shopkeeper' ? '#ffd166' : npc.gang.color;
      ctx.beginPath();
      ctx.arc(npc.x, npc.y, npc.interactRadius, 0, TAU);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    
    // NPC sprite rendering
    let npcSprite = null;
    if(npc.type === 'shopkeeper') {
      npcSprite = document.getElementById('npcShopkeeper');
    } else if(npc.type === 'gang_leader' && npc.gang) {
      if(npc.gang.leader === 'A Pimp Named Slickback') npcSprite = document.getElementById('npcSlickback');
      else if(npc.gang.leader === 'Deebo') npcSprite = document.getElementById('npcDeebo');
      else if(npc.gang.leader === 'Smokey') npcSprite = document.getElementById('npcSmokey');
      else if(npc.gang.leader === 'Craig') npcSprite = document.getElementById('npcCraig');
    }
    
    if(isImageReady(npcSprite)) {
      // Draw NPC sprite
      const spriteW = 48, spriteH = 64;
      ctx.drawImage(npcSprite, 
        npc.x - spriteW/2, npc.y - spriteH/2, 
        spriteW, spriteH
      );
    } else {
      // Fallback: colored circle with outline
      const npcColor = npc.type === 'shopkeeper' ? '#ffd166' : npc.gang.color;
      ctx.strokeStyle = npcColor;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(npc.x, npc.y, 22, 0, TAU);
      ctx.stroke();
      
      ctx.fillStyle = npcColor;
      ctx.beginPath();
      ctx.arc(npc.x, npc.y, 20, 0, TAU);
      ctx.fill();
      
      // NPC type indicator
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 16px system-ui, sans-serif';
      ctx.textAlign = 'center';
      const icon = npc.type === 'shopkeeper' ? '$' : '!';
      ctx.fillText(icon, npc.x, npc.y + 6);
    }
    
    // Interaction prompt
    if(canInteract){
      // Floating prompt with background
      const promptY = npc.y - 50;
      let text = '';
      if(npc.type === 'gang_leader') {
        text = '[T] Talk to ' + npc.gang.leader;
      } else if(npc.type === 'shopkeeper') {
        text = '[T] Browse Shop';
      }
      
      ctx.font = 'bold 14px system-ui, sans-serif';
      const metrics = ctx.measureText(text);
      const padding = 8;
      
      // Background box
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.fillRect(npc.x - metrics.width/2 - padding, promptY - 16, metrics.width + padding*2, 24);
      
      // Text
      ctx.fillStyle = '#ffd166';
      ctx.textAlign = 'center';
      ctx.fillText(text, npc.x, promptY);
    }
  }
  
  // Helper function to get boss sprite prefix based on boss type
  function getBossSpritePrefix(bossType) {
    switch(bossType) {
      case 'sex_trafficker': return 'bossTrafficker';
      case 'chain_snatcher': return 'bossSnatcher';
      case 'rainbow_hippie': return 'bossHippie';
      case 'fake_king': return 'bossKing';
      default: return 'bossTrafficker'; // fallback
    }
  }

  // Draw quest enemies and boss in interiors
  if(inInterior && currentInterior?.interior?.questEnemies) {
    const interior = currentInterior.interior;
    
    // Draw quest enemies
    interior.questEnemies.forEach(enemy => {
      if(!enemy.alive) return;
      
      // Enemy body (red circle)
      ctx.fillStyle = '#ff6b6b';
      ctx.beginPath();
      ctx.arc(enemy.x, enemy.y, 15, 0, TAU);
      ctx.fill();
      
      // Enemy outline
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Health bar
      const barWidth = 30;
      const barHeight = 4;
      const healthPct = enemy.hp / enemy.maxHp;
      
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(enemy.x - barWidth/2, enemy.y - 25, barWidth, barHeight);
      
      ctx.fillStyle = healthPct > 0.3 ? '#4CAF50' : '#ff6b6b';
      ctx.fillRect(enemy.x - barWidth/2, enemy.y - 25, barWidth * healthPct, barHeight);
      
      // Status effect visuals
      if(enemy.burnT > 0) {
        ctx.fillStyle = 'rgba(255, 100, 100, 0.7)';
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, 18, 0, TAU);
        ctx.fill();
        // Burning particles
        if(Math.random() < 0.3) {
          particles.push({alive:true, x:enemy.x + (Math.random()-0.5)*20, y:enemy.y + (Math.random()-0.5)*20, vx:0, vy:-20, life:0.5, type:'burnSpark'});
        }
      }
      if(enemy.iceT > 0) {
        ctx.fillStyle = 'rgba(100, 200, 255, 0.5)';
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, 18, 0, TAU);
        ctx.fill();
      }
      if(enemy.shockT > 0) {
        ctx.fillStyle = 'rgba(255, 255, 100, 0.7)';
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, 18, 0, TAU);
        ctx.fill();
      }
    });
    
    // Draw quest boss
    const boss = interior.npc;
    if(boss && boss.type === 'quest_boss' && boss.alive) {
      // Get boss sprite based on type and animation state
      let bossSprite = null;
      const spritePrefix = getBossSpritePrefix(boss.bossType);
      
      if(boss.animDir === 'left') {
        const frame = boss.animPhase ? '2' : '1';
        bossSprite = document.getElementById(`${spritePrefix}L${frame}`);
      } else if(boss.animDir === 'right') {
        const frame = boss.animPhase ? '2' : '1';
        bossSprite = document.getElementById(`${spritePrefix}R${frame}`);
      } else {
        // idle, up, down all use idle sprite
        bossSprite = document.getElementById(`${spritePrefix}Idle`);
      }
      
      // Draw boss sprite if available and ready
      if(bossSprite && isImageReady(bossSprite)) {
        const scale = TUNE.sprites.enemy.questBoss.scale;
        const offsetY = TUNE.sprites.enemy.questBoss.offsetY;
        const w = bossSprite.naturalWidth * scale;
        const h = bossSprite.naturalHeight * scale;
        
        ctx.drawImage(bossSprite, 
          boss.x - w/2, 
          boss.y - h/2 + offsetY, 
          w, h);
      } else {
        // Fallback to circle if sprite not ready
        ctx.fillStyle = boss.questActive ? '#8b0000' : '#666';
        ctx.beginPath();
        ctx.arc(boss.x, boss.y, 25, 0, TAU);
        ctx.fill();
        
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      
      // Quest boss status effect visuals
      if(boss.burnT > 0) {
        ctx.fillStyle = 'rgba(255, 100, 100, 0.6)';
        ctx.beginPath();
        ctx.arc(boss.x, boss.y, 30, 0, TAU);
        ctx.fill();
        // Burning particles
        if(Math.random() < 0.5) {
          particles.push({alive:true, x:boss.x + (Math.random()-0.5)*40, y:boss.y + (Math.random()-0.5)*40, vx:0, vy:-25, life:0.7, type:'burnSpark'});
        }
      }
      if(boss.iceT > 0) {
        ctx.fillStyle = 'rgba(100, 200, 255, 0.4)';
        ctx.beginPath();
        ctx.arc(boss.x, boss.y, 30, 0, TAU);
        ctx.fill();
      }
      if(boss.shockT > 0) {
        ctx.fillStyle = 'rgba(255, 255, 100, 0.6)';
        ctx.beginPath();
        ctx.arc(boss.x, boss.y, 30, 0, TAU);
        ctx.fill();
      }
      
      // Boss indicator
      ctx.fillStyle = '#ffd166';
      ctx.font = 'bold 18px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('BOSS', boss.x, boss.y - 35);
      
      // Boss health bar (larger)
      if(boss.questActive) {
        const barWidth = 60;
        const barHeight = 6;
        const healthPct = boss.hp / boss.maxHp;
        
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(boss.x - barWidth/2, boss.y - 45, barWidth, barHeight);
        
        ctx.fillStyle = healthPct > 0.3 ? '#ff8c00' : '#ff4444';
        ctx.fillRect(boss.x - barWidth/2, boss.y - 45, barWidth * healthPct, barHeight);
      }
      
      // Boss interaction prompt
      if(!boss.questActive && playerGang && playerGang.name === boss.gang.name) {
        const dist = Math.hypot(player.x - boss.x, player.y - boss.y);
        if(dist < boss.interactRadius) {
          ctx.fillStyle = 'rgba(0,0,0,0.8)';
          ctx.fillRect(boss.x - 60, boss.y + 35, 120, 20);
          
          ctx.fillStyle = '#ffd166';
          ctx.font = 'bold 12px system-ui, sans-serif';
          ctx.fillText('[T] Start Quest', boss.x, boss.y + 48);
        }
      }
    }
  }
  
  // Draw door interaction prompt in interiors
  if(inInterior && currentInterior?.interior?.door){
    const door = currentInterior.interior.door;
    const playerAtDoor = player.x > door.x + 5 && player.x < door.x + door.w - 5 && 
                        player.y > door.y + 5 && player.y < door.y + door.h - 5;
    
    if(playerAtDoor){
      // More prominent prompt background
      ctx.fillStyle = 'rgba(0,0,0,0.9)';
      ctx.fillRect(door.x - 25, door.y - 35, door.w + 50, 25);
      
      // Border for the prompt
      ctx.strokeStyle = '#ffd166';
      ctx.lineWidth = 2;
      ctx.strokeRect(door.x - 25, door.y - 35, door.w + 50, 25);
      
      // Text
      ctx.fillStyle = '#ffd166';
      ctx.font = 'bold 14px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('[F] Exit Building', door.x + door.w/2, door.y - 18);
      
      // Small arrow pointing to door
      ctx.fillStyle = '#ffd166';
      ctx.beginPath();
      ctx.moveTo(door.x + door.w/2 - 5, door.y - 10);
      ctx.lineTo(door.x + door.w/2 + 5, door.y - 10);
      ctx.lineTo(door.x + door.w/2, door.y - 5);
      ctx.closePath();
      ctx.fill();
    }
  }

  ctx.restore(); // restore from world-space

  // Minimap
  const mmc=$('#miniMapCanvas'); if(mmc && mmc.getContext){ const mg=mmc.getContext('2d'); const mW=mmc.width, mH=mmc.height; mg.clearRect(0,0,mW,mH); mg.globalAlpha=.95; mg.fillStyle='#0b111c'; mg.fillRect(0,0,mW,mH); mg.strokeStyle='#203047'; mg.strokeRect(0,0,mW,mH); const sx=mW/WORLD.W, sy=mH/WORLD.H; mg.fillStyle='#12314f'; obstacles.forEach(o=>mg.fillRect(o.x*sx, o.y*sy, o.w*sx, o.h*sy)); mg.fillStyle='#61dafb'; mg.fillRect(player.x*sx-2, player.y*sy-2, 4,4); mg.fillStyle='#ff6060'; enemies.forEach(e=>{if(e.alive) mg.fillRect(e.x*sx-2, e.y*sy-2, 4,4);}); 
    // POI stars on minimap edges (arrows) and centers
    if(game.stage===2){ mg.fillStyle='#ffd166'; stage2POIs.forEach(p=>{ mg.fillRect(p.x*sx-2, p.y*sy-2, 4,4); }); }
  }

  // boss power-up ring (overlay so it appears on top)
  { const boss = enemies.find(e=>e.alive && e.type==='boss' && (e.powerUp||0)>0); if(boss){ const t = clamp((boss.powerUp||0)/5,0,1); ctx.save(); ctx.translate(ox,oy); ctx.scale(camera.zoom, camera.zoom); ctx.translate(-camera.x, -camera.y); ctx.globalAlpha=0.75*(0.4+0.6*t); ctx.strokeStyle=TUNE.boss.color||'#ffcc33'; ctx.lineWidth=3; ctx.beginPath(); const rr = boss.r + 8 + (1-t)*30; ctx.arc(boss.x, boss.y, rr, 0, TAU); ctx.stroke(); ctx.restore(); } }
  // Draw buildings and vehicles in world (overworld only)
  // moved inside world transform earlier
  if(false){}
  
}

// -----------------------------
// Start in menu
// -----------------------------
show('menu', true); switchToMenuMusic();

// TEMP: Skip wave for testing


// Some browsers block autoplay until a gesture; ensure menu music starts on first interaction
function isPlaying(el){ try{ return el && !el.paused && !el.ended && el.currentTime>0; }catch(_){ return false; } }
function ensureMenuMusicOnGesture(){ if(game.state===STATE.MENU){ const el=document.getElementById('bgm_menu'); if(!isPlaying(el)){ switchToMenuMusic(); } } }
window.addEventListener('pointerdown', ensureMenuMusicOnGesture);
window.addEventListener('keydown', ensureMenuMusicOnGesture);

// draw rope during pull even if bullet ended
if(player.grappling && player.grappleRopePts && player.grappleRopePts.length>0){ ctx.strokeStyle='#d9dee6'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(player.x,player.y); for(const pt of player.grappleRopePts){ ctx.lineTo(pt.x,pt.y); } ctx.lineTo(player.grappleX,player.grappleY); ctx.stroke(); }

// Stage 2 state
let stage2Transition={active:false, t:0, phase:'idle', qZoom:0, tourQueue:null, curSeg:null, segT:0}; // phases: 'prep','show','return'

// Gang System
const gangs = {
  uptown: {
    name: 'Uptown Elite',
    leader: 'Craig',
    color: '#9c4dc4',
    zone: 'topRight',
    dialogue: "*nods respectfully* 'Sup. Name's Craig. *extends fist for dap* I'mma keep it real with you - no games, no BS. The Uptown Elite is about power. Raw, undeniable power. Every bullet counts, every shot matters. We don't spray and pray like these other cats. We AIM. We EXECUTE. *taps temple* It's chess, not checkers, you feel me? Look around Uptown. We built this. Protected this. When trouble comes knocking, they know the Uptown Elite don't play. Your weapons? They gonna hit like freight trains. One shot, one kill - that's our motto. We about precision, we about respect, and we about getting the job DONE. *looks you in the eye* I see potential in you. Question is - you ready to maximize it? You ready to be about that action, or you just another talker?",
    questDialogue: "*clenches fist* Yo, I got a serious problem that needs handling. There's this annoying hippie fool wearing rainbow tie-dye running around MY territory acting like he owns the place. Talking about 'peace and love' and spreading his flower power BS to MY people! *shakes head* This cat is disrupting our precision operation with his chaotic energy. He's in that old warehouse on the east side of Uptown, probably meditating or some nonsense. I need you to go in there and show him what REAL power looks like. Take him and his crew out - permanently. You handle this for me, there's an extra 100 in it for you. What you say? You ready to eliminate this colorful clown?",
    perks: {
      damageMultiplier: 1.4,
      critChance: 0.15,
      penetration: true
    },
    questBoss: {
      name: 'Rainbow Hippie',
      description: 'An annoying tie-dye wearing hippie disrupting Uptown operations'
    }
  },
  compton: {
    name: 'Compton Crew',
    leader: 'Deebo',
    color: '#dc3545',
    zone: 'bottomLeft',
    dialogue: "*cracks knuckles* So you think you tough enough to roll with the Compton Crew? *stares intensely* Name's Deebo. You probably heard about me. I run these Compton streets with an iron fist - literally. We don't do fancy, we don't do pretty. We do STRONG. We do SURVIVAL. You see that punk over there? That was MY bike. Now it's MY bike again. That's how we operate. You join us, you become a walking tank. More health than these other fools can dream of. Armor so thick bullets bounce off. Stamina for days - you won't get tired when we're putting in work. This ain't no social club, this is a FAMILY. And family protects family. So... *leans in close* ...you ready to get your hands dirty? Or you gonna run home to mama?",
    questDialogue: "*pounds fist on table* Listen up! Some punk-ass thug tried to jack me for my chain last week. MY CHAIN! *touches gold chain around neck* Nobody - and I mean NOBODY - tries to rob Deebo and lives to tell about it. This fool thinks he's tough, got himself holed up in that old crack house on the south side of Compton with his crew. He's been telling people he 'punked' Deebo! *laughs menacingly* That's gonna stop TODAY. I want you to roll up in there and show him what happens when you mess with the wrong one. Bring me his chain as proof you handled business. Do this, and I'll throw you an extra 100 for your trouble. You ready to ride or die for the Crew?",
    perks: {
      healthBonus: 50,
      armorBonus: 5,
      staminaBonus: 30
    },
    questBoss: {
      name: 'Chain Snatcher',
      description: 'A notorious thug who tried to rob Deebo for his chain'
    }
  },
  downtown: {
    name: 'Downtown Syndicate',
    leader: 'Smokey',
    color: '#4a90e2',
    zone: 'bottomRight',
    dialogue: "*takes a long draw and exhales* Ayyyy, what's good, homie? *laughs* They call me Smokey, and before you ask - no, I ain't got none on me right now! *laughs harder* Man, you look all serious and stuff. Relax! See, that's what the Downtown Syndicate is all about - staying smooth, staying fast, staying ALIVE! We ain't the biggest, we ain't the strongest, but we the QUICKEST. Both in body and mind, you feel me? *does a little dance move* You join us, you gonna be moving like water - fluid, fast, untouchable. Bullets? Please, they can't hit what they can't catch! Your guns gonna sing like birds - rat-tat-tat-tat! *mimics shooting* Reload so fast they think you got infinite ammo! We keep it light, we keep it fun, but don't get it twisted - we handle our business in Downtown. So what you say? Ready to join the syndicate? *grins widely*",
    questDialogue: "*gets serious for once* Yo, check this out. There's this NBA player dude who moved into MY neighborhood thinking he runs everything now. *shakes head* This cat's going around claiming he's the 'King of LA' and all that. *voice gets passionate* But hold up - ain't nobody the king of LA except Kobe, man! KOBE! *pounds chest* This wannabe baller is disrespecting the memory of the real king, setting up shop in that fancy penthouse downtown, acting like he owns the place. *takes a deep breath* Look, I'm usually chill, but this... this crosses the line. I need you to go handle this fraud and his security team. Show him that Downtown belongs to US, not some fake king. You do this for me, I got 100 coins with your name on it. You feel me? Time to school this pretender.",
    perks: {
      speedBonus: 1.3,
      fireRateBonus: 1.25,
      reloadSpeed: 1.4
    },
    questBoss: {
      name: 'Fake King',
      description: 'An NBA player claiming to be the King of LA, disrespecting Kobe\'s memory'
    }
  },
  hollywood: {
    name: 'Hollywood Kings',
    leader: 'A Pimp Named Slickback',
    color: '#5cb85c',
    zone: 'topLeft',
    dialogue: "Well, well, well... *adjusts purple fedora* Look what we got here. Another wannabe trying to make it in this city. The name's A Pimp Named Slickback - yes, you say the WHOLE thing. It's like A Tribe Called Quest. You don't just call them 'Tribe', do you? *chuckles smoothly* Listen here, baby. We run the finest operation in Hollywood. Class, style, and sophistication - that's what we're about. You join us, you get the VIP treatment everywhere you go. Shops give you the friends and family discount, you learn faster than these other chumps out here, and you get access to our premium fleet of rides. We're talking leather seats, chrome rims, the whole nine yards. So what's it gonna be? You ready to step up your game and roll with the Hollywood Kings?",
    questDialogue: "*face darkens, adjusts fedora* Now listen here, baby... A Pimp Named Slickback has got a serious problem that requires immediate attention. There's some sick, twisted individual running a sex trafficking operation in MY territory. *voice gets cold* Now, A Pimp Named Slickback appreciates the art of pimping - it's about style, class, and mutual respect. But this animal? He's taking girls against their will, hurting them, treating them like property. *slams fist* That's not pimping, that's pure evil! This scumbag has set up shop in that old motel on the west side of Hollywood, thinking he can operate under MY nose. *straightens suit* I need you to go in there and end this fool permanently. Save any girls you can, but make sure that trafficker never hurts another soul. Handle this with the precision and class befitting a Hollywood King. There's 100 coins in it for you when it's done. Can I count on you?",
    perks: {
      shopDiscount: 0.25,
      xpMultiplier: 1.5,
      carSpeed: 1.3
    },
    questBoss: {
      name: 'Sex Trafficker',
      description: 'A major sex trafficker operating in Hollywood against Slickback\'s code'
    }
  }
};

let playerGang = null;
let gangInteractionActive = false;
let shopInteractionActive = false;

// Player Equippables System
let playerEquippables = [];
let playerVehicles = {
  superCar: {type: 'super_car', unlocked: false},
  ferrari: {type: 'ferrari', unlocked: false}, 
  armoredVan: {type: 'armored_van', unlocked: false}
};

// Gang Shop Items - Special weapons, equippables and vehicles for each gang
const gangShopItems = {
  uptown: [
    // Special Gang Weapon
    {key: 'bolt_sniper', name: 'Bolt Action Sniper', basePrice: 100, desc: 'Ultra-powerful sniper rifle. One shot, one kill.', type: 'weapon', sprite: 'weapon_bolt_sniper.png'},
    // Gang-Specific Equippables  
    {key: 'precision_scope', name: 'Tactical Scope', basePrice: 75, desc: '+40% weapon damage and accuracy.', type: 'equippable', sprite: 'equip_precision_scope.png'},
    {key: 'focus_enhancer', name: 'Focus Pills', basePrice: 60, desc: '+15% critical hit chance and penetration.', type: 'equippable', sprite: 'equip_focus_pills.png'}
  ],
  compton: [
    // Special Gang Weapon
    {key: 'double_shotgun', name: 'Double Pump Shotgun', basePrice: 100, desc: 'Devastating shotgun with double barrels and more pellets.', type: 'weapon', sprite: 'weapon_double_shotgun.png'},
    // Gang-Specific Equippables
    {key: 'heavy_armor', name: 'Reinforced Vest', basePrice: 80, desc: '+50 Max HP and +10 Armor.', type: 'equippable', sprite: 'equip_heavy_armor.png'},
    {key: 'rage_serum', name: 'Adrenaline Injector', basePrice: 65, desc: '+50 Max Stamina and health regen.', type: 'equippable', sprite: 'equip_rage_serum.png'}
  ],
  downtown: [
    // Special Gang Weapon
    {key: 'compact_smg', name: 'Compact SMG', basePrice: 100, desc: 'Lightning-fast SMG with 0.2s reload and extreme fire rate.', type: 'weapon', sprite: 'weapon_compact_smg.png'},
    // Gang-Specific Equippables
    {key: 'rapid_fire', name: 'Hair Trigger Mod', basePrice: 70, desc: '+25% fire rate and reload speed for all weapons.', type: 'equippable', sprite: 'equip_rapid_fire.png'},
    {key: 'agility_boost', name: 'Speed Boots', basePrice: 55, desc: '+30% movement speed and reduced stamina cost.', type: 'equippable', sprite: 'equip_speed_boots.png'}
  ],
  hollywood: [
    // Special Gang Weapons (2 weapons)
    {key: 'desert_eagle', name: 'Desert Eagle', basePrice: 100, desc: 'High-powered pistol with devastating damage per shot.', type: 'weapon', sprite: 'weapon_desert_eagle.png'},
    {key: 'ak47', name: 'AK-47', basePrice: 100, desc: 'Legendary assault rifle with superior damage and range.', type: 'weapon', sprite: 'weapon_ak47.png'},
    // Gang-Specific Equippables
    {key: 'explosive_rounds', name: 'Explosive Ammo', basePrice: 90, desc: 'Shop discount bonus and XP multiplier.', type: 'equippable', sprite: 'equip_explosive_rounds.png'},
    {key: 'luxury_access', name: 'VIP Card', basePrice: 75, desc: 'Enhanced vehicle speed and performance.', type: 'equippable', sprite: 'equip_vip_card.png'},
    // Special Vehicles (2 vehicles)
    {key: 'ferrari', name: 'Ferrari Supercar', basePrice: 300, desc: 'Ultimate speed machine with 50% speed boost.', type: 'vehicle', sprite: 'vehicle_ferrari.png'},
    {key: 'armored_van', name: 'Armored Van', basePrice: 350, desc: 'Heavily armored vehicle with 3x health.', type: 'vehicle', sprite: 'vehicle_armored_van.png'}
  ]
};

// Objectives System
const objectives=[
  {key:'joinGang', title:'Join a gang', detail:'Find a gang HQ and enter to initiate recruitment.', done:false}
];
let currentObjectiveIndex=0;
function updateObjectivesHUD(){ 
  const ul=$('#objectivesList'); 
  if(!ul) return; 
  ul.innerHTML=''; 
  objectives.forEach((o,i)=>{ 
    const li=document.createElement('li'); 
    li.style.marginBottom='4px';
    li.style.position='relative';
    li.style.paddingLeft='20px';
    const marker = document.createElement('span');
    marker.style.position='absolute';
    marker.style.left='0';
    marker.style.top='2px';
    marker.textContent = o.done? '✓' : '◆';
    marker.style.color = o.done? '#9cff57' : '#ffd166';
    marker.style.textShadow = '0 2px 4px rgba(0,0,0,0.5)';
    li.appendChild(marker);
    const text = document.createElement('span');
    text.textContent = o.title;
    text.style.color = i===currentObjectiveIndex? '#fff' : (o.done?'#9cff57':'#c9d0db');
    text.style.fontSize = i===currentObjectiveIndex? '14px' : '13px';
    text.style.fontWeight = i===currentObjectiveIndex? '700' : '600';
    if(i===currentObjectiveIndex && !o.done) {
      text.style.textShadow = '0 0 8px rgba(255,209,102,0.5)';
    }
    li.appendChild(text);
    ul.appendChild(li); 
  }); 
}
function showObjectivesPanel(){ const cont=$('#objectivesDetail'); cont.innerHTML=''; objectives.forEach(o=>{ const d=document.createElement('div'); d.className='perk'; d.innerHTML=`<h3>${o.title}</h3><div class="muted small">${o.detail}</div>`; cont.appendChild(d); }); show('objectivesPanel', true); }
$('#pauseObjectivesBtn').onclick=()=>showObjectivesPanel();
$('#closeObjectives').onclick=()=>show('objectivesPanel', false);
updateObjectivesHUD();

// Gang dialogue handlers
function showGangDialogue(gang){
  gangInteractionActive = true;
  game.state = STATE.PAUSE;
  $('#gangLeaderName').textContent = gang.leader;
  
  // Show quest dialogue if player is already in this gang, otherwise show recruitment dialogue
  let dialogueText = gang.dialogue;
  if(playerGang && playerGang.name === gang.name) {
    dialogueText = gang.questDialogue || gang.dialogue;
  }
  
  $('#gangDialogue').innerHTML = dialogueText.replace(/\*(.*?)\*/g, '<em style="color:#ffd166;">$1</em>');
  $('#gangLeaderSprite').style.borderColor = gang.color;
  $('#gangLeaderSprite').style.backgroundColor = gang.color + '22';
  show('gangDialoguePanel', true);
}

$('#joinGangBtn').onclick = ()=>{
  if(!gangInteractionActive) return;
  const npc = currentInterior?.interior?.npc;
  if(!npc) return;
  
  playerGang = npc.gang;
  
  // Give 100 coins for joining gang
  game.coins += 100;
  updateShopCoins();
  
  objectives[0].done = true;
  objectives.push({
    key: 'firstQuest',
    title: `Eliminate ${playerGang.questBoss.name}`,
    detail: `Your gang leader wants you to take out ${playerGang.questBoss.name}. Check the quest building in your territory.`,
    done: false
  });
  currentObjectiveIndex = 1;
  updateObjectivesHUD();
  
  // Apply gang perks
  if(playerGang.perks.healthBonus){
    player.hpMax += playerGang.perks.healthBonus;
    player.hp += playerGang.perks.healthBonus;
  }
  if(playerGang.perks.armorBonus){
    player.armor += playerGang.perks.armorBonus;
  }
  if(playerGang.perks.staminaBonus){
    player.staminaMax += playerGang.perks.staminaBonus;
    player.stamina = player.staminaMax;
  }
  
  show('gangDialoguePanel', false);
  gangInteractionActive = false;
  game.state = STATE.RUN;
};

$('#declineGangBtn').onclick = ()=>{
  show('gangDialoguePanel', false);
  gangInteractionActive = false;
  game.state = STATE.RUN;
};

// Quest Fight System
function startQuestFight(questBoss) {
  if(questBoss.questActive) return; // Already in progress
  
  questBoss.questActive = true;
  const interior = currentInterior?.interior;
  if(!interior) return;
  
  // Activate all quest enemies
  interior.questEnemies.forEach(enemy => {
    enemy.alive = true;
    enemy.hp = enemy.maxHp;
  });
  
  // Show quest start message
  showMessage(`Quest Started: Eliminate ${questBoss.bossType.replace('_', ' ')} and all enemies!`);
}

function showMessage(text) {
  // Simple message display
  const messageDiv = document.createElement('div');
  messageDiv.style.position = 'fixed';
  messageDiv.style.top = '50%';
  messageDiv.style.left = '50%';
  messageDiv.style.transform = 'translate(-50%, -50%)';
  messageDiv.style.background = 'rgba(0,0,0,0.8)';
  messageDiv.style.color = '#ffd166';
  messageDiv.style.padding = '20px';
  messageDiv.style.borderRadius = '10px';
  messageDiv.style.fontSize = '18px';
  messageDiv.style.zIndex = '1000';
  messageDiv.textContent = text;
  
  document.body.appendChild(messageDiv);
  
  setTimeout(() => {
    document.body.removeChild(messageDiv);
  }, 3000);
}

function checkQuestCompletion() {
  if(!inInterior || !currentInterior?.interior) return;
  
  const interior = currentInterior.interior;
  const boss = interior.npc;
  
  if(boss && boss.type === 'quest_boss' && boss.questActive && boss.alive) {
    // Check if all quest enemies are dead
    const aliveEnemies = interior.questEnemies.filter(e => e.alive).length;
    
    if(aliveEnemies === 0 && !boss.alive) {
      // Quest completed!
      boss.questActive = false;
      interior.questCompleted = true;
      
      // Give reward
      game.coins += 100;
      updateShopCoins();
      
      // Update objectives
      if(objectives[currentObjectiveIndex] && objectives[currentObjectiveIndex].key === 'firstQuest') {
        objectives[currentObjectiveIndex].done = true;
        updateObjectivesHUD();
      }
      
      showMessage(`Quest Completed! You earned 100 coins. ${boss.bossType.replace('_', ' ')} has been eliminated!`);
    }
  }
}

// Shop interaction handlers
function showShop(gang, shopkeeper){
  shopInteractionActive = true;
  game.state = STATE.PAUSE;
  
  const gangKey = gang.zone === 'topLeft' ? 'hollywood' : 
                  gang.zone === 'topRight' ? 'uptown' :
                  gang.zone === 'bottomLeft' ? 'compton' : 'downtown';
  
  $('#shopTitle').textContent = `${gang.name} Supply Store`;
  $('#shopSubtitle').textContent = `Exclusive gear and upgrades`;
  $('#shopCoinsDisplay').textContent = game.coins;
  
  // Populate shop items
  const itemsGrid = $('#shopItemsGrid');
  itemsGrid.innerHTML = '';
  
  const items = gangShopItems[gangKey] || [];
  items.forEach((item, index) => {
    // New pricing logic
    let finalPrice;
    let discount = 0;
    let discountText = '';
    
    if(playerGang && playerGang.name === gang.name) {
      // Same gang: base price is 100 for weapons, regular price for others
      finalPrice = item.type === 'weapon' ? 100 : item.basePrice;
    } else if(playerGang && playerGang.name === 'Hollywood Kings') {
      // Hollywood gang member buying from other gangs: 150 for ALL items
      finalPrice = 150;
    } else if(playerGang) {
      // Different gang: 500 for all items
      finalPrice = 500;
    } else {
      // No gang: 500 for all items (no discounts without gang membership)
      finalPrice = 500;
    }
    
    if(finalPrice < item.basePrice) {
      discount = Math.floor((1 - finalPrice / item.basePrice) * 100);
      discountText = `${discount}% Gang Discount`;
    }
    
    const itemCard = document.createElement('div');
    itemCard.className = 'content-card';
    itemCard.style.cursor = 'pointer';
    
    itemCard.innerHTML = `
      <h3>${item.name}</h3>
      <div class="muted small" style="margin-bottom:12px;">${item.desc}</div>
      <div class="tag" style="background:var(--gang-${gangKey});color:white;margin-bottom:8px;">${item.type.toUpperCase()}</div>
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div>
          ${discount > 0 ? `<div style="text-decoration:line-through;color:var(--text-muted);font-size:12px;">${item.basePrice}c</div>` : ''}
          <div class="price">${finalPrice}c</div>
          ${discountText ? `<div style="color:var(--accent-success);font-size:11px;">${discountText}</div>` : ''}
        </div>
        <button class="btn ${game.coins >= finalPrice ? 'primary' : ''}" 
                ${game.coins < finalPrice ? 'disabled' : ''}>
          ${game.coins >= finalPrice ? 'Buy' : 'Too Expensive'}
        </button>
      </div>
    `;
    
    const buyBtn = itemCard.querySelector('button');
    if(game.coins >= finalPrice) {
      buyBtn.onclick = () => buyShopItem(item, finalPrice, itemsGrid);
    }
    
    itemsGrid.appendChild(itemCard);
  });
  
  show('shopPanel', true);
}

function buyShopItem(item, price, itemsGrid) {
  if(game.coins < price) return;
  
  game.coins -= price;
  $('#shopCoinsDisplay').textContent = game.coins;
  updateShopCoins();
  
  // Handle different item types
  if(item.type === 'weapon') {
    // Add special weapon to player's arsenal
    const weapon = newWeapon(item.key);
    player.weapons.push(weapon);
    console.log(`Acquired special weapon: ${item.name}`);
  } else if(item.type === 'equippable') {
    // Add equippable item (permanent passive bonus)
    if(!playerEquippables.includes(item.key)) {
      playerEquippables.push(item.key);
      applyEquippableBonus(item.key);
      console.log(`Equipped: ${item.name}`);
    }
  } else if(item.type === 'vehicle') {
    // Unlock and spawn special vehicle at player location
    if(item.key === 'ferrari') {
      playerVehicles.ferrari.unlocked = true;
      // Add ferrari to parked vehicles at current location
      parkedVehicles.push({x: player.x + 30, y: player.y, vehicleType: 'ferrari'});
      console.log(`Unlocked and spawned Ferrari Supercar!`);
    } else if(item.key === 'armored_van') {
      playerVehicles.armoredVan.unlocked = true;
      // Add armored van to parked vehicles at current location
      parkedVehicles.push({x: player.x + 30, y: player.y, vehicleType: 'armored_van'});
      console.log(`Unlocked and spawned Armored Van!`);
    }
  }
  
  updateWeaponDisplay();
  
  // Refresh shop display
  const gang = currentInterior?.interior?.npc?.gang;
  if(gang) {
    setTimeout(() => showShop(gang, null), 100);
  }
}

// Apply equippable bonuses
function applyEquippableBonus(equipKey) {
  switch(equipKey) {
    case 'precision_scope':
      player.equipBonuses = player.equipBonuses || {};
      player.equipBonuses.damageBonus = (player.equipBonuses.damageBonus || 1) * 1.4;
      break;
    case 'focus_enhancer':
      player.equipBonuses = player.equipBonuses || {};
      player.equipBonuses.critChance = (player.equipBonuses.critChance || 0) + 0.15;
      break;
    case 'heavy_armor':
      player.hpMax += 50;
      player.armor += 10;
      break;
    case 'rage_serum':
      player.staminaMax += 50;
      player.equipBonuses = player.equipBonuses || {};
      player.equipBonuses.healthRegen = true;
      break;
    case 'rapid_fire':
      player.equipBonuses = player.equipBonuses || {};
      player.equipBonuses.fireRateBonus = (player.equipBonuses.fireRateBonus || 1) * 1.25;
      player.equipBonuses.reloadBonus = (player.equipBonuses.reloadBonus || 1) * 1.25;
      break;
    case 'agility_boost':
      player.equipBonuses = player.equipBonuses || {};
      player.equipBonuses.speedBonus = (player.equipBonuses.speedBonus || 1) * 1.3;
      break;
    case 'explosive_rounds':
      player.equipBonuses = player.equipBonuses || {};
      player.equipBonuses.explosiveRounds = true;
      break;
    case 'luxury_access':
      player.equipBonuses = player.equipBonuses || {};
      player.equipBonuses.vehicleSpeedBonus = (player.equipBonuses.vehicleSpeedBonus || 1) * 1.3;
      break;
  }
}

  $('#closeShopBtn').onclick = ()=>{
    show('shopPanel', false);
    shopInteractionActive = false;
    game.state = STATE.RUN;
  };
  
  function updateShopCoins() {
    if($('#shopCoinsDisplay')) {
      $('#shopCoinsDisplay').textContent = game.coins;
    }
  }

// Stage 2 POI star markers (zone centers and minimap edge hints)
let stage2POIs=[];
function buildStage2POIs(){ stage2POIs.length=0; const cx0=(WORLD.W-G.W)/2, cy0=(WORLD.H-G.H)/2; const leftX=0, midX=cx0, rightX=cx0+G.W; const topY=0, midY=cy0, bottomY=cy0+G.H; const centers=[ {x:(leftX+midX)/2,y:(topY+midY)/2}, {x:(rightX+WORLD.W)/2,y:(topY+midY)/2}, {x:(leftX+midX)/2,y:(bottomY+WORLD.H)/2}, {x:(rightX+WORLD.W)/2,y:(bottomY+WORLD.H)/2} ]; stage2POIs.push(...centers); }

// Stage 2 world build and transition - Now uses biome system
function buildStage2World(){
  // Calculate world size based on biome extents
  let maxX = 0, maxY = 0;
  for(const biome of TUNE.biomes.instances) {
    maxX = Math.max(maxX, biome.x + biome.w);
    maxY = Math.max(maxY, biome.y + biome.h);
  }
  setWorldSize(maxX, maxY);
  
  // Clear old obstacles and build biome-based obstacles
  obstacles.length=0;
  buildBiomeObstacles();
  buildBiomeBuildings();
  
  // Place super car and player in center of the world for Stage 2
  const centerBiome = getBiomeById('center_borough');
  if(centerBiome) {
    superCar.alive=true; 
    // Position at world center for dramatic reveal
    superCar.x = WORLD.W / 2; 
    superCar.y = WORLD.H / 2; 
    player.x = superCar.x + 28; 
    player.y = superCar.y; 
    centerCameraOn(player.x, player.y);
  }
  updateObjectivesHUD();
}

// Build obstacles using TUNE configuration
function buildBiomeObstacles() {
  if(TUNE.obstacles.generation.enabled) {
    // Use automatic generation
    buildAutomaticObstacles();
  } else {
    // Use manual configuration from TUNE.obstacles.instances
    buildManualObstacles();
  }
}

// Build obstacles from manual TUNE configuration
function buildManualObstacles() {
  for(const obstacleConfig of TUNE.obstacles.instances) {
    // Validate obstacle is within its biome bounds
    const biome = getBiomeById(obstacleConfig.biome);
    if(biome && isObstacleInBiome(obstacleConfig, biome)) {
      obstacles.push({
        id: obstacleConfig.id,
        x: obstacleConfig.x,
        y: obstacleConfig.y,
        w: obstacleConfig.w,
        h: obstacleConfig.h,
        biome: obstacleConfig.biome
      });
    }
  }
}

// Build obstacles automatically (legacy behavior)
function buildAutomaticObstacles() {
  for(const biome of TUNE.biomes.instances) {
    if(biome.type === 'borough' && biome.config.hasObstacles && TUNE.obstacles.generation.boroughTileMode) {
      buildBoroughObstacles(biome);
    } else if(biome.type === 'zone' && TUNE.obstacles.generation.zoneRandomMode) {
      buildZoneObstacles(biome);
    }
  }
}

// Validate obstacle is within biome bounds
function isObstacleInBiome(obstacle, biome) {
  return obstacle.x >= biome.x && 
         obstacle.y >= biome.y && 
         obstacle.x + obstacle.w <= biome.x + biome.w && 
         obstacle.y + obstacle.h <= biome.y + biome.h;
}

// Build obstacles for borough biome (original tile system) - legacy
function buildBoroughObstacles(biome) {
  const bg = document.getElementById('bgImg');
  if(!isImageReady(bg)) return;
  
  const scale = biome.config.tileScale || 1;
  const tw = Math.max(8, Math.floor(bg.naturalWidth * scale));
  const th = Math.max(8, Math.floor(bg.naturalHeight * scale));
  const rects = TUNE.background.tileRects || [];
  const offset = biome.config.obstacleOffset || {x: 0, y: 0};
  
  for(let y = biome.y; y < biome.y + biome.h; y += th) {
    for(let x = biome.x; x < biome.x + biome.w; x += tw) {
      for(const r of rects) {
        const ox = x + Math.floor(r.x * tw) + offset.x;
        const oy = y + Math.floor(r.y * th) + offset.y;
        const ow = Math.floor(r.w * tw);
        const oh = Math.floor(r.h * th);
        
        // Only add if within biome bounds
        if(ox >= biome.x && oy >= biome.y && 
           ox + ow <= biome.x + biome.w && oy + oh <= biome.y + biome.h) {
          obstacles.push({x: ox, y: oy, w: ow, h: oh, biome: biome.id});
        }
      }
    }
  }
}

// Build random obstacles for zone biomes - legacy
function buildZoneObstacles(biome) {
  const count = biome.config.obstacleCount || 14;
  const gen = TUNE.obstacles.generation;
  const pad = gen.padding || 40;
  
  for(let i = 0; i < count; i++) {
    const w = R.rint(60, 220);
    const h = R.rint(40, 180);
    const x = R.rint(biome.x + pad, Math.max(biome.x + pad, biome.x + biome.w - w - pad));
    const y = R.rint(biome.y + pad, Math.max(biome.y + pad, biome.y + biome.h - h - pad));
    obstacles.push({x, y, w, h, biome: biome.id});
  }
}

function enterStage2(){ game.stage=2; game.state=STATE.STAGE2; stage2Transition={active:true, t:0, phase:'prep'}; show('stage2Panel', true); bullets.length=0; enemies.length=0; particles.length=0; drops.length=0; floats.length=0; const objHUD=$('#objectivesHUD'); if(objHUD) objHUD.style.display='block'; }
$('#stage2StartBtn').onclick=()=>{ if(!stage2Transition.active) return; show('stage2Panel', false); // begin zoom out and world build
  buildStage2World();
  // Adjust scale/zoom
  camera.follow=false; camera.lock=true;
  // Smooth zoom out to fit whole world and center it slowly
  camera.lerpSpeed = TUNE.camera.transitionZoom.speed || 0.5; // slower zoom for smoother reveal
  camera.targetZoom = fitZoomWholeWorld(); centerWorldViewAtCurrentZoom(); 
  stage2Transition.phase='show'; stage2Transition.t=6.0; stage2Transition.tourQueue=null; 
  // Add dramatic fade effect
  const fade = document.createElement('div');
  fade.style.position = 'fixed';
  fade.style.inset = '0';
  fade.style.background = 'black';
  fade.style.pointerEvents = 'none';
  fade.style.opacity = '1';
  fade.style.transition = 'opacity 2s ease-out';
  fade.style.zIndex = '9999';
  document.body.appendChild(fade);
  setTimeout(() => { fade.style.opacity = '0'; }, 100);
  setTimeout(() => { fade.remove(); }, 2100);
};

// Buildings & Interiors - Rebuilt System
const buildings=[]; // {x,y,w,h, door:{x,y,w,h}, interior:{entry:{x,y}, door:{x,y,w,h}, obstacles:[...], rect:{x,y,w,h}, npc}}
let inInterior=false, currentInterior=null, returnPos=null;

function addBuilding(x,y,w,h, door, type='hq'){ 
  buildings.push({x,y,w,h,door, interior:null, type:type}); 
}

function genInteriorFor(b, index){ 
  // Use building configuration if available, otherwise use defaults
  const config = b.config || {};
  const interiorSize = config.interiorSize || {w: 800, h: 600};
  const obstacleCount = config.interiorObstacles || 8;
  
  // Place interiors way outside the main map to avoid any overlap
  const pad = 5000;
  const offset = (index + 1) * pad; 
  const ix = WORLD.W * 2 + offset;
  const iy = WORLD.H * 2 + offset; 
  const iw = interiorSize.w, ih = interiorSize.h;
  
  // Door at bottom center edge
  const door = {
    x: ix + iw/2 - 30, 
    y: iy + ih - 10,  // Right at the bottom edge
    w: 60, 
    h: 10
  }; 
  
  // Entry point well inside the room, away from the door
  const entry = {
    x: ix + iw/2, 
    y: iy + ih - 120  // Much further from the door
  }; 
  
  // Generate interior obstacles
  const obs = []; 
  for(let i = 0; i < obstacleCount; i++){ 
    const w = R.rint(60, 180); 
    const h = R.rint(50, 120); 
    const ox = R.rint(ix + 40, ix + iw - 40 - w); 
    const oy = R.rint(iy + 40, iy + ih - 100 - h); 
    obs.push({x:ox, y:oy, w:w, h:h}); 
  }
  
  // Determine gang from building configuration
  let gang = null;
  if(b.gang) {
    gang = gangs[b.gang];
  } else {
    // Legacy fallback - determine by building index
    const zoneIndex = Math.floor(index / 2);
    if(zoneIndex === 0) gang = gangs.uptown;
    else if(zoneIndex === 1) gang = gangs.hollywood;
    else if(zoneIndex === 2) gang = gangs.compton;
    else if(zoneIndex === 3) gang = gangs.downtown;
  }
  
  // Create appropriate NPC based on building configuration
  let npc = null;
  const npcType = config.npcType || (b.type === 'hq' ? 'gang_leader' : 'shopkeeper');
  
  if(npcType === 'gang_leader' && gang) {
    npc = {
      x: ix + iw/2,
      y: iy + 100,
      gang: gang,
      interactRadius: 60,
      type: 'gang_leader'
    };
  } else if(npcType === 'shopkeeper' && gang) {
    npc = {
      x: ix + iw/2,
      y: iy + 100,
      gang: gang, // Associated gang for pricing
      interactRadius: 60,
      type: 'shopkeeper'
    };
  } else if(npcType === 'quest_boss' && gang) {
    npc = {
      x: ix + iw/2,
      y: iy + 150,
      gang: gang,
      bossType: config.bossType || 'generic_boss',
      interactRadius: 80,
      type: 'quest_boss',
      hp: 300, // Boss health
      maxHp: 300,
      maxhp: 300, // needed for damageEnemy function
      alive: true,
      questActive: false,
      r: 25, // collision radius
      // Animation properties
      animDir: 'idle', // idle, left, right
      animT: 0,        // animation timer
      animPhase: false, // false = frame1, true = frame2
      lastX: ix + iw/2, // track last position for direction
      lastY: iy + 150
    };
  }
  
  // Add quest enemies if this is a quest building
  const questEnemies = [];
  if(b.type === 'quest' && config.enemyCount) {
    for(let i = 0; i < config.enemyCount; i++) {
      const ex = R.rint(ix + 100, ix + iw - 100);
      const ey = R.rint(iy + 100, iy + ih - 200);
      questEnemies.push({
        x: ex,
        y: ey,
        hp: 60,
        maxHp: 60,
        maxhp: 60, // needed for damageEnemy function
        alive: true,
        type: 'grunt',
        moveSpeed: 80,
        lastShot: 0,
        fireRate: 1500,
        r: 15, // collision radius
        t: 0   // time tracker for consistency with regular enemies
      });
    }
  }

  b.interior = {
    entry: entry, 
    door: door, 
    obstacles: obs, 
    rect: {x:ix, y:iy, w:iw, h:ih}, 
    npc: npc,
    type: b.type,
    questEnemies: questEnemies,
    questCompleted: false
  }; 
}

function enterBuilding(b){ 
  if(player.inVehicle) return; 
  if(!b.interior){ 
    const idx = buildings.indexOf(b); 
    genInteriorFor(b, idx >= 0 ? idx : 0); 
  } 
  
  inInterior = true; 
  currentInterior = b; 
  returnPos = {x: player.x, y: player.y};
  
  // Teleport player to interior
  player.x = currentInterior.interior.entry.x; 
  player.y = currentInterior.interior.entry.y;
  
  // Adjust camera for interior view
  const r = b.interior.rect;
  // Calculate zoom to fit interior nicely on screen
  const zoomX = G.W / r.w;
  const zoomY = G.H / r.h;
  const padding = TUNE.camera.interiorZoom.padding || 1.2;
  const fitZ = Math.min(zoomX, zoomY) / padding; // Apply configurable padding
  
  camera.targetZoom = fitZ; 
  camera.zoom = fitZ;
  camera.follow = true; // Keep follow mode on
  
  // Center camera on the player in the interior
  centerCameraOn(player.x, player.y);
  
  // Debug log
  console.log('Entered building:', {
    playerPos: {x: player.x, y: player.y},
    entryPos: currentInterior.interior.entry,
    doorPos: currentInterior.interior.door,
    interiorRect: r,
    cameraPos: {x: camera.x, y: camera.y},
    zoom: camera.zoom
  });
}

function exitBuilding(){ 
  if(!currentInterior) return; 
  
  inInterior = false; 
  
  // Place player outside the building door, not inside it
  const building = currentInterior;
  const buildingDoor = building.door;
  const exitX = buildingDoor.x + buildingDoor.w/2; // Center of door
  const exitY = buildingDoor.y + buildingDoor.h + 30; // 30 pixels below the door
  
  // Return player to overworld position
  player.x = exitX; 
  player.y = exitY; 
  
  // Reset camera for overworld
  const stage1Zoom = TUNE.camera.stage1Zoom || 1.0;
  const stage2Zoom = TUNE.camera.stage2Zoom || 0.7;
  camera.targetZoom = game.stage === 2 ? stage2Zoom : stage1Zoom;
  camera.follow = true;
  
  currentInterior = null; 
  returnPos = null;
  
  centerCameraOn(player.x, player.y);
  
  console.log('Exited building:', {
    playerPos: {x: player.x, y: player.y},
    buildingDoor: buildingDoor,
    cameraPos: {x: camera.x, y: camera.y}
  });
}

// Build buildings using TUNE configuration
function buildBiomeBuildings() {
  buildings.length = 0;
  
  if(TUNE.buildings.generation.enabled) {
    // Use automatic generation
    buildAutomaticBuildings();
  } else {
    // Use manual configuration from TUNE.buildings.instances
    buildManualBuildings();
  }
}

// Build buildings from manual TUNE configuration
function buildManualBuildings() {
  for(const buildingConfig of TUNE.buildings.instances) {
    // Validate building is within its biome bounds
    const biome = getBiomeById(buildingConfig.biome);
    if(biome && isBuildingInBiome(buildingConfig, biome)) {
      // Create building object with all configuration
      const building = {
        id: buildingConfig.id,
        type: buildingConfig.type,
        x: buildingConfig.x,
        y: buildingConfig.y,
        w: buildingConfig.w,
        h: buildingConfig.h,
        door: {...buildingConfig.door},
        biome: buildingConfig.biome,
        gang: buildingConfig.gang,
        config: {...buildingConfig.config},
        interior: null // Will be generated when needed
      };
      
      buildings.push(building);
    }
  }
}

// Build buildings automatically (legacy behavior)
function buildAutomaticBuildings() {
  const zoneBiomes = getBiomesByType('zone');
  const gen = TUNE.buildings.generation;
  
  zoneBiomes.forEach((biome, index) => {
    const centerX = biome.x + biome.w / 2;
    const centerY = biome.y + biome.h / 2;
    
    // HQ building at center
    const hqX = centerX - gen.hqSize.w / 2;
    const hqY = centerY - gen.hqSize.h / 2;
    const hqDoor = {
      x: hqX + (gen.hqSize.w - gen.doorSize.hq.w) / 2,
      y: hqY + gen.hqSize.h - gen.doorSize.hq.h,
      w: gen.doorSize.hq.w,
      h: gen.doorSize.hq.h
    };
    addBuilding(hqX, hqY, gen.hqSize.w, gen.hqSize.h, hqDoor, 'hq');
    
    // Shop building nearby
    const shopX = centerX + gen.spacing - gen.shopSize.w / 2;
    const shopY = centerY - gen.shopSize.h / 2;
    const shopDoor = {
      x: shopX + (gen.shopSize.w - gen.doorSize.shop.w) / 2,
      y: shopY + gen.shopSize.h - gen.doorSize.shop.h,
      w: gen.doorSize.shop.w,
      h: gen.doorSize.shop.h
    };
    addBuilding(shopX, shopY, gen.shopSize.w, gen.shopSize.h, shopDoor, 'shop');
  });
}

// Validate building is within biome bounds
function isBuildingInBiome(building, biome) {
  return building.x >= biome.x && 
         building.y >= biome.y && 
         building.x + building.w <= biome.x + biome.w && 
         building.y + building.h <= biome.y + biome.h;
}

// Legacy function - now handled by buildBiomeBuildings()
function placeStage2Buildings(){ 
  buildBiomeBuildings();
}

})();
</script>
</body>
</html>
